<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>喬喬</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-02-26T09:10:06.106Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>乔乔</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于http</title>
    <link href="http://yoursite.com/2020/02/26/%E5%85%B3%E4%BA%8Ehttp/"/>
    <id>http://yoursite.com/2020/02/26/关于http/</id>
    <published>2020-02-26T09:05:10.000Z</published>
    <updated>2020-02-26T09:10:06.106Z</updated>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h3 id=&quot;基本概念：&quot;&gt;&lt;a href=&quot;#基本概念：&quot; class=&quot;headerlink&quot; title=&quot;基本概念：&quot;&gt;&lt;/a&gt;基本概念：&lt;/h3&gt;&lt;p&gt;HTTP，全称为 HyperText Transfer Protocol，即为超文本传输协议。是互联网应用最为广泛的一种网络协议&lt;br&gt;所有的 www 文件都必须遵守这个标准。&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
  </entry>
  
  <entry>
    <title>this指向以及 call appy bind用法</title>
    <link href="http://yoursite.com/2020/02/26/this%E6%8C%87%E5%90%91%E4%BB%A5%E5%8F%8A-call-appy-bind%E7%94%A8%E6%B3%95/"/>
    <id>http://yoursite.com/2020/02/26/this指向以及-call-appy-bind用法/</id>
    <published>2020-02-26T08:57:18.000Z</published>
    <updated>2020-02-26T09:04:21.287Z</updated>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;在 ES5 中，其实 this 的指向，始终坚持一个原理：this 永远指向最后调用它的那个对象&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
  </entry>
  
  <entry>
    <title>Var&amp;Let&amp;Const</title>
    <link href="http://yoursite.com/2020/01/13/Var-Let-Const/"/>
    <id>http://yoursite.com/2020/01/13/Var-Let-Const/</id>
    <published>2020-01-13T09:35:36.000Z</published>
    <updated>2020-01-14T03:37:54.000Z</updated>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;ES5只有全局作用域和函数作用域，没有块级作用域,这带来很多不合理的场景,比如内层变量可能覆盖外层变量，用来计数的循环变量泄露为全局变量，ES6引入了块级作用域来强化对变量生命周期的控制，新增了let和const两个命令，这两个命令的用法类似于var，但是又和var有所不同。&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>React源码解析之Component和PureComponent</title>
    <link href="http://yoursite.com/2019/09/03/React%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BComponent%E5%92%8CPureComponent/"/>
    <id>http://yoursite.com/2019/09/03/React源码解析之Component和PureComponent/</id>
    <published>2019-09-03T07:46:03.000Z</published>
    <updated>2019-09-03T09:36:25.000Z</updated>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;默认渲染行为&quot;&gt;&lt;a href=&quot;#默认渲染行为&quot; class=&quot;headerlink&quot; title=&quot;默认渲染行为&quot;&gt;&lt;/a&gt;默认渲染行为&lt;/h1&gt;&lt;p&gt;在React Component的生命周期中，有一个shouldComponentUpdate方法，这个方法是用来控制组件是否被更新的，返回为true的话，则当props或state改变的时候进行更新，如果返回false，当props或state改变的时候不更新，默认返回值是true，这就意味着就算没有改变组件的props或state，也会导致组件的重绘。这就经常导致组件因为不相关数据的改变导致重绘，这极大的降低了React的渲染效率。（这里的更新不更新，其实说的是执不执行render函数，如果不执行render函数，那自然该组件和其子组件都不会重新渲染啦）&lt;/p&gt;
    
    </summary>
    
      <category term="react" scheme="http://yoursite.com/categories/react/"/>
    
    
      <category term="React源码学习" scheme="http://yoursite.com/tags/React%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>React源码解析之ReactElement</title>
    <link href="http://yoursite.com/2019/08/29/React%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BReactElement/"/>
    <id>http://yoursite.com/2019/08/29/React源码解析之ReactElement/</id>
    <published>2019-08-29T09:56:17.000Z</published>
    <updated>2019-09-03T03:41:24.000Z</updated>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;学习react的源码，我们先从简单的ReactElement学起，ReactElement通过createElement创建的，JSX只是为React.createElement(component,props,…children)方法提供的语法糖。当我们写下一段JSX代码的时候，react是如何根据我们的JSX代码来生成虚拟DOM的组成元素element的？首先，它会经过babel 编译成React.createElement的表达式，&lt;a href=&quot;https://babeljs.io/repl&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;戳这里&lt;/a&gt;演示。&lt;/p&gt;
    
    </summary>
    
      <category term="react" scheme="http://yoursite.com/categories/react/"/>
    
    
      <category term="React源码学习" scheme="http://yoursite.com/tags/React%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>React API</title>
    <link href="http://yoursite.com/2019/08/29/React-API/"/>
    <id>http://yoursite.com/2019/08/29/React-API/</id>
    <published>2019-08-29T08:53:14.000Z</published>
    <updated>2019-09-03T07:43:37.000Z</updated>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;将react作为核心架构的人很多，但其实很多人都不知道react到底是个什么东东。如果你去看源码会发现，react的源码只有1000多行，儿react-dom却有近2W行，你的眼睛是好的，没有看错，大部分的架构逻辑都在react-dom当中，那么react到底是个什么东东呢？？？&lt;/p&gt;
    
    </summary>
    
      <category term="react" scheme="http://yoursite.com/categories/react/"/>
    
    
      <category term="React源码学习" scheme="http://yoursite.com/tags/React%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>写在react源码学习前的破烂话</title>
    <link href="http://yoursite.com/2019/08/29/%E5%86%99%E5%9C%A8react%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E5%89%8D%E7%9A%84%E7%A0%B4%E7%83%82%E8%AF%9D/"/>
    <id>http://yoursite.com/2019/08/29/写在react源码学习前的破烂话/</id>
    <published>2019-08-29T03:16:26.000Z</published>
    <updated>2019-08-29T03:17:29.000Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;hr&gt;
&lt;p&gt;看react的源码这个事情，我从2018年就开始计划，但是到2019年的9月份，这个事情依然是断断续续的，看了一些也是一知半解的，有时候我觉得自己才入门，但是有时候我又觉得自己没有入门，反正不管有没有入门，爱过还是恨过，过去的就过去吧，以前的就算翻篇了，从现在开始
        
      
    
    </summary>
    
      <category term="react" scheme="http://yoursite.com/categories/react/"/>
    
    
      <category term="React源码学习" scheme="http://yoursite.com/tags/React%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>继承</title>
    <link href="http://yoursite.com/2019/08/20/%E7%BB%A7%E6%89%BF/"/>
    <id>http://yoursite.com/2019/08/20/继承/</id>
    <published>2019-08-20T09:55:40.000Z</published>
    <updated>2019-09-03T02:32:46.000Z</updated>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;什么是继承？就是获取存在对象已有属性和方法的一种方式。 &lt;/p&gt;
&lt;p&gt;由于函数没有签名，在 ECMAScript 中无法实现接口继承，因此，ECMAScript只支持实现继承，而实现继承主要是依靠原型链实现的，基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。  &lt;/p&gt;
&lt;p&gt;简单的回顾一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="Object" scheme="http://yoursite.com/tags/Object/"/>
    
  </entry>
  
  <entry>
    <title>原型链</title>
    <link href="http://yoursite.com/2019/08/19/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://yoursite.com/2019/08/19/原型链/</id>
    <published>2019-08-19T09:56:10.000Z</published>
    <updated>2019-09-05T07:25:58.000Z</updated>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;如果说上次说原型就让你吐血了，那这篇原型链可能让你马上气绝身亡。 哈哈哈。。。其实原型链这个家伙，说难很难，说简单也简单，接下来就让我来说道说道，准备好救心丸！！！！&lt;br&gt;原型链的顶层就是Object.prototype，而这个对象的是没有原型对象的，在chrome控制台中输入Object.&lt;code&gt;__proto__&lt;/code&gt;，输出是ƒ () {  }，一个空的函数。&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="Object" scheme="http://yoursite.com/tags/Object/"/>
    
  </entry>
  
  <entry>
    <title>原型</title>
    <link href="http://yoursite.com/2019/08/16/%E5%8E%9F%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/08/16/原型/</id>
    <published>2019-08-16T10:29:15.000Z</published>
    <updated>2020-02-26T08:56:46.482Z</updated>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;对于初学者来说，JavaScript的原型是一件让人头疼甚至吐血的事情，prototype和&lt;code&gt;__proto__&lt;/code&gt;又让人傻傻分不清，虽然网上有很多相关资料，还有一张经典的图，线条很多，看的就头疼，更甚者吐血身亡，就算是对于“老人”，也不好整明白呀，或者好不容易搞清楚了，过几天又忘了（我就是这样，嘿嘿）。接下来请允许我尽可能形象生动的来阐述明白，哈哈哈哈哈。。。&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="Object" scheme="http://yoursite.com/tags/Object/"/>
    
  </entry>
  
  <entry>
    <title>面向对象的程序设计模式</title>
    <link href="http://yoursite.com/2019/08/15/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/08/15/面向对象的程序设计模式/</id>
    <published>2019-08-15T02:58:55.000Z</published>
    <updated>2019-09-03T03:40:42.000Z</updated>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;工厂模式&quot;&gt;&lt;a href=&quot;#工厂模式&quot; class=&quot;headerlink&quot; title=&quot;工厂模式&quot;&gt;&lt;/a&gt;工厂模式&lt;/h2&gt;&lt;p&gt;工厂模式是软件工程领域一种广为认知的设计模式。&lt;br&gt;工厂模式虽然解决了创建多个对象的问题，但却没有解决对象的识别问题（即怎样知道一个对象的类型）。&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="Object" scheme="http://yoursite.com/tags/Object/"/>
    
  </entry>
  
  <entry>
    <title>理解对象</title>
    <link href="http://yoursite.com/2019/08/12/%E7%90%86%E8%A7%A3%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2019/08/12/理解对象/</id>
    <published>2019-08-12T08:08:41.000Z</published>
    <updated>2019-08-16T10:28:38.000Z</updated>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;什么是对象？&quot;&gt;&lt;a href=&quot;#什么是对象？&quot; class=&quot;headerlink&quot; title=&quot;什么是对象？&quot;&gt;&lt;/a&gt;什么是对象？&lt;/h2&gt;&lt;p&gt;对象是无序属性的集合，其属性可以包含基本值、对象或者函数，在javascript中，对象是拥有属性和方法的数据。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;每个对象都是基于一个引用类创建的。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="Object" scheme="http://yoursite.com/tags/Object/"/>
    
  </entry>
  
  <entry>
    <title>节流函数和防抖函数</title>
    <link href="http://yoursite.com/2019/03/26/%E8%8A%82%E6%B5%81%E5%87%BD%E6%95%B0%E5%92%8C%E9%98%B2%E6%8A%96%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2019/03/26/节流函数和防抖函数/</id>
    <published>2019-03-26T09:12:36.000Z</published>
    <updated>2020-02-26T09:13:55.925Z</updated>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;“节流”与“防抖”的本质： 这两个东西都以闭包的形式存在。&lt;/p&gt;
&lt;p&gt;它们通过对事件对应的回调函数进行包裹、以自由变量的形式缓存时间信息，最后用 setTimeout 来控制事件的触发频率。防抖函数和节流函数都是用来提升性能优化及用户体验的一种方案；&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
  </entry>
  
  <entry>
    <title>同源策略和跨域</title>
    <link href="http://yoursite.com/2019/02/26/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E5%92%8C%E8%B7%A8%E5%9F%9F/"/>
    <id>http://yoursite.com/2019/02/26/同源策略和跨域/</id>
    <published>2019-02-26T09:10:58.000Z</published>
    <updated>2020-02-26T09:12:51.610Z</updated>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h3 id=&quot;浏览器的同源策略&quot;&gt;&lt;a href=&quot;#浏览器的同源策略&quot; class=&quot;headerlink&quot; title=&quot;浏览器的同源策略&quot;&gt;&lt;/a&gt;浏览器的同源策略&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;浏览器安全的基石是“同源策略”（same-origin policy）。所谓“同源”指的是“三个相同”：&lt;/p&gt;
&lt;p&gt;  协议相同&lt;br&gt;  域名相同&lt;br&gt;  端口相同&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
  </entry>
  
  <entry>
    <title>回流（Reflow）与重绘（Repaint）</title>
    <link href="http://yoursite.com/2018/07/26/%E5%9B%9E%E6%B5%81%EF%BC%88Reflow%EF%BC%89%E4%B8%8E%E9%87%8D%E7%BB%98%EF%BC%88Repaint%EF%BC%89/"/>
    <id>http://yoursite.com/2018/07/26/回流（Reflow）与重绘（Repaint）/</id>
    <published>2018-07-26T05:14:19.000Z</published>
    <updated>2020-02-26T09:16:19.314Z</updated>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;strong&gt;回流&lt;/strong&gt;：浏览器要花时间去渲染页面，当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，影响到了布局，&lt;br&gt;浏览器需要倒回去重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），&lt;br&gt;然后再将计算的结果绘制出来。这个过程就是回流（也叫重排）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重绘&lt;/strong&gt;：当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，&lt;br&gt;浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（跳过了上图所示的回流环节）。这个过程叫做重绘。&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
  </entry>
  
  <entry>
    <title>判断一个变量是不是空对象</title>
    <link href="http://yoursite.com/2018/06/16/%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%E6%98%AF%E4%B8%8D%E6%98%AF%E7%A9%BA%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2018/06/16/判断一个变量是不是空对象/</id>
    <published>2018-06-16T02:17:12.000Z</published>
    <updated>2020-02-26T09:18:24.003Z</updated>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;判断一个变量是不是空对象分为两步：&lt;br&gt;1）判断一个变量是不是对象&lt;br&gt;2）判断一个这个对象是否为空&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
  </entry>
  
</feed>
