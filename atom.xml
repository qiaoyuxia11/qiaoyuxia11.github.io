<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>喬喬</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-03T09:36:25.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>乔乔</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React源码解析之Component和PureComponent</title>
    <link href="http://yoursite.com/2019/09/03/React%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BComponent%E5%92%8CPureComponent/"/>
    <id>http://yoursite.com/2019/09/03/React源码解析之Component和PureComponent/</id>
    <published>2019-09-03T07:46:03.000Z</published>
    <updated>2019-09-03T09:36:25.000Z</updated>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;默认渲染行为&quot;&gt;&lt;a href=&quot;#默认渲染行为&quot; class=&quot;headerlink&quot; title=&quot;默认渲染行为&quot;&gt;&lt;/a&gt;默认渲染行为&lt;/h1&gt;&lt;p&gt;在React Component的生命周期中，有一个shouldComponentUpdate方法，这个方法是用来控制组件是否被更新的，返回为true的话，则当props或state改变的时候进行更新，如果返回false，当props或state改变的时候不更新，默认返回值是true，这就意味着就算没有改变组件的props或state，也会导致组件的重绘。这就经常导致组件因为不相关数据的改变导致重绘，这极大的降低了React的渲染效率。（这里的更新不更新，其实说的是执不执行render函数，如果不执行render函数，那自然该组件和其子组件都不会重新渲染啦）&lt;/p&gt;
    
    </summary>
    
      <category term="react" scheme="http://yoursite.com/categories/react/"/>
    
    
      <category term="React源码学习" scheme="http://yoursite.com/tags/React%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>React源码解析之ReactElement</title>
    <link href="http://yoursite.com/2019/08/29/React%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BReactElement/"/>
    <id>http://yoursite.com/2019/08/29/React源码解析之ReactElement/</id>
    <published>2019-08-29T09:56:17.000Z</published>
    <updated>2019-09-03T03:41:24.000Z</updated>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;学习react的源码，我们先从简单的ReactElement学起，ReactElement通过createElement创建的，JSX只是为React.createElement(component,props,…children)方法提供的语法糖。当我们写下一段JSX代码的时候，react是如何根据我们的JSX代码来生成虚拟DOM的组成元素element的？首先，它会经过babel 编译成React.createElement的表达式，&lt;a href=&quot;https://babeljs.io/repl&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;戳这里&lt;/a&gt;演示。&lt;/p&gt;
    
    </summary>
    
      <category term="react" scheme="http://yoursite.com/categories/react/"/>
    
    
      <category term="React源码学习" scheme="http://yoursite.com/tags/React%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>React API</title>
    <link href="http://yoursite.com/2019/08/29/React-API/"/>
    <id>http://yoursite.com/2019/08/29/React-API/</id>
    <published>2019-08-29T08:53:14.000Z</published>
    <updated>2019-09-03T07:43:37.000Z</updated>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;将react作为核心架构的人很多，但其实很多人都不知道react到底是个什么东东。如果你去看源码会发现，react的源码只有1000多行，儿react-dom却有近2W行，你的眼睛是好的，没有看错，大部分的架构逻辑都在react-dom当中，那么react到底是个什么东东呢？？？&lt;/p&gt;
    
    </summary>
    
      <category term="react" scheme="http://yoursite.com/categories/react/"/>
    
    
      <category term="React源码学习" scheme="http://yoursite.com/tags/React%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>写在react源码学习前的破烂话</title>
    <link href="http://yoursite.com/2019/08/29/%E5%86%99%E5%9C%A8react%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E5%89%8D%E7%9A%84%E7%A0%B4%E7%83%82%E8%AF%9D/"/>
    <id>http://yoursite.com/2019/08/29/写在react源码学习前的破烂话/</id>
    <published>2019-08-29T03:16:26.000Z</published>
    <updated>2019-08-29T03:17:29.000Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;hr&gt;
&lt;p&gt;看react的源码这个事情，我从2018年就开始计划，但是到2019年的9月份，这个事情依然是断断续续的，看了一些也是一知半解的，有时候我觉得自己才入门，但是有时候我又觉得自己没有入门，反正不管有没有入门，爱过还是恨过，过去的就过去吧，以前的就算翻篇了，从现在开始
        
      
    
    </summary>
    
      <category term="react" scheme="http://yoursite.com/categories/react/"/>
    
    
      <category term="React源码学习" scheme="http://yoursite.com/tags/React%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>继承</title>
    <link href="http://yoursite.com/2019/08/20/%E7%BB%A7%E6%89%BF/"/>
    <id>http://yoursite.com/2019/08/20/继承/</id>
    <published>2019-08-20T09:55:40.000Z</published>
    <updated>2019-09-03T02:32:46.000Z</updated>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;什么是继承？就是获取存在对象已有属性和方法的一种方式。 &lt;/p&gt;
&lt;p&gt;由于函数没有签名，在 ECMAScript 中无法实现接口继承，因此，ECMAScript只支持实现继承，而实现继承主要是依靠原型链实现的，基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。  &lt;/p&gt;
&lt;p&gt;简单的回顾一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="Object" scheme="http://yoursite.com/tags/Object/"/>
    
  </entry>
  
  <entry>
    <title>原型链</title>
    <link href="http://yoursite.com/2019/08/19/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://yoursite.com/2019/08/19/原型链/</id>
    <published>2019-08-19T09:56:10.000Z</published>
    <updated>2019-09-05T07:25:58.000Z</updated>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;如果说上次说原型就让你吐血了，那这篇原型链可能让你马上气绝身亡。 哈哈哈。。。其实原型链这个家伙，说难很难，说简单也简单，接下来就让我来说道说道，准备好救心丸！！！！&lt;br&gt;原型链的顶层就是Object.prototype，而这个对象的是没有原型对象的，在chrome控制台中输入Object.&lt;code&gt;__proto__&lt;/code&gt;，输出是ƒ () {  }，一个空的函数。&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="Object" scheme="http://yoursite.com/tags/Object/"/>
    
  </entry>
  
  <entry>
    <title>原型</title>
    <link href="http://yoursite.com/2019/08/16/%E5%8E%9F%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/08/16/原型/</id>
    <published>2019-08-16T10:29:15.000Z</published>
    <updated>2020-01-13T06:50:27.000Z</updated>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;对于初学者来说，JavaScript的原型是一件让人头疼甚至吐血的事情，prototype和&lt;code&gt;__proto__&lt;/code&gt;又让人傻傻分不清，虽然网上有很多相关资料，还有一张经典的图，线条很多，看的就头疼，更甚者吐血身亡，就算是对于“老人”，也不好整明白呀，或者好不容易搞清楚了，过几天又忘了（我就是这样，嘿嘿）。接下来请允许我尽可能形象生动的来阐述明白，哈哈哈哈哈。。。&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="Object" scheme="http://yoursite.com/tags/Object/"/>
    
  </entry>
  
  <entry>
    <title>面向对象的程序设计模式</title>
    <link href="http://yoursite.com/2019/08/15/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/08/15/面向对象的程序设计模式/</id>
    <published>2019-08-15T02:58:55.000Z</published>
    <updated>2019-09-03T03:40:42.000Z</updated>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;工厂模式&quot;&gt;&lt;a href=&quot;#工厂模式&quot; class=&quot;headerlink&quot; title=&quot;工厂模式&quot;&gt;&lt;/a&gt;工厂模式&lt;/h2&gt;&lt;p&gt;工厂模式是软件工程领域一种广为认知的设计模式。&lt;br&gt;工厂模式虽然解决了创建多个对象的问题，但却没有解决对象的识别问题（即怎样知道一个对象的类型）。&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="Object" scheme="http://yoursite.com/tags/Object/"/>
    
  </entry>
  
  <entry>
    <title>理解对象</title>
    <link href="http://yoursite.com/2019/08/12/%E7%90%86%E8%A7%A3%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2019/08/12/理解对象/</id>
    <published>2019-08-12T08:08:41.000Z</published>
    <updated>2019-08-16T10:28:38.000Z</updated>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;什么是对象？&quot;&gt;&lt;a href=&quot;#什么是对象？&quot; class=&quot;headerlink&quot; title=&quot;什么是对象？&quot;&gt;&lt;/a&gt;什么是对象？&lt;/h2&gt;&lt;p&gt;对象是无序属性的集合，其属性可以包含基本值、对象或者函数，在javascript中，对象是拥有属性和方法的数据。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;每个对象都是基于一个引用类创建的。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="Object" scheme="http://yoursite.com/tags/Object/"/>
    
  </entry>
  
</feed>
