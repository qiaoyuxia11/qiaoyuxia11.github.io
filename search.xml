<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[this指向以及 call appy bind用法]]></title>
    <url>%2F2020%2F02%2F26%2Fthis%E6%8C%87%E5%90%91%E4%BB%A5%E5%8F%8A-call-appy-bind%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在 ES5 中，其实 this 的指向，始终坚持一个原理：this 永远指向最后调用它的那个对象 图解： 全局环境下的thisnodejs环境1console.log(this) // &#123;&#125; 浏览器环境 全局环境下的this，在nodejs中是{}，实际指向的是module.exports这个模块作用域,，浏览器指向的是Window。 函数内（function）中的thisnodejs 非严格模式下123456function fn()&#123; return this&#125;const result = fn() console.log(result) // Object [global] &#123;...&#125;console.log(result === global) // true 浏览器环境 非严格模式下 nodejs 严格模式下1234567function fn()&#123; 'use strict' return this&#125;const result = fn() console.log(result) // undefinedconsole.log(result === undefined) // true 浏览器环境下 严格模式下 总结： 非严格模式下，函数内this的指向nodejs：global浏览器：window 严格模式下，函数内this的指向nodejs：undefined浏览器：undefined 构造函数内的this12345function Person(name)&#123; this.name = name&#125;const p = new Person('zhangsan')console.log(p.name) // zhangsan 例子可以看出，当经过new关键字来声明一个对象时，这里的this实际指向的是他的实例。 改变this的指向（call，apply，bind）call语法：function.call(thisArgs,arg1,arg2, …)第一个参数代表function函数内this值，可选。arg1,arg2, … 123456789101112function Person() &#123; this.name = 'ipenman' this.sayHi = function() &#123; console.log(`My name is $&#123;this.name&#125;`) &#125;&#125;function Man() &#123; this.name = 'zhangsan'&#125;const man = new Man()const p = new Person()p.sayHi.call(man) // zhangsan 用法总结 用array将一个数组push到另一个数组中 1234let arr1=[1,2,3]let arr2=[4,5]Array.prototype.push.apply(arr1,arr2) console.log(arr1) // [1,2,3,4,5] 如果直接使用arr1.push(arr2)得到的结果将会是一个数组作为整体传入。得不到我们想要的效果。而直接使用concat的话，它返回的是一个新的数组，而不会对arr1进行修改。 求数组中最大值 123let number=[1,2,4,56,6]let max=Math.max.apply(null,number)console.log(max) 因为Math.max接收的参数为离散数，直接传入数组无法的到想要的结果。这种调用方式相当于Math.max(1,2,4,56,6) 继承 123456789101112131415161718function Person(name)&#123; this.name=name this.say=function()&#123; console.log('my name is ' + name) &#125;&#125;function My(name,age)&#123; Person.apply(this,[name]) this.age=age this.getAge=function()&#123; console.log(age) &#125;&#125;let my=new My('hkj',22)console.log(my.name)my.say()console.log(my.age)my.getAge() 通过new生成的实例会继承构造函数中的属性和方法，而My中定义的只有age及getAge方法，并未定义name及say方法。但是生成的实例依然可以调用，这就是apply的借用导致的。虽然My未定义此方法但是借了个Person里的name属性和say方法来用。换成术语就是，My继承了Person中this绑定的属性和方法。 类似用法还有很多，就不在此赘述了。只需要牢记借用这个概念就能记住它的用法了。apply语法：function.apply(thisArgs,[arg1,arg2, …])第一个参数代表function函数内的this值，可选。[arg1,arg2, …] 指定参数列表 123456789101112function Person() &#123; this.name = 'ipenman' this.sayHi = function() &#123; console.log(`My name is $&#123;this.name&#125;`) &#125;&#125;function Man() &#123; this.name = 'zhangsan'&#125;const man = new Man()const p = new Person()p.sayHi.apply(man) // zhangsan 用法Object.prototype.toString判断数据类型 类型判断一直是个比较棘手的问题，而Object的toString方法则是最完美的解决办法。默认情况下调用返回值为[object Object]。后面的Object就是返回的类型123456var toString = Object.prototype.toString;toString.call(new Date); // [object Date]toString.call(new String); // [object String]toString.call(Math); // [object Math]toString.call(undefined); // [object Undefined]toString.call(null); // [object Null] 可以看出第二个值表示的就是正确返回类型。如果直接调用的话，有些对象重写了toString方法将会得不到我们想要的效果。 eg: 123456789let arr=[1]let date=new Date()let fun = function () &#123;&#125;console.log(date.toString()) // Thu Dec 05 2019 16:46:51 GMT+0800 (中国标准时间)console.log(arr.toString()) // 1console.log(fun) // ƒ () &#123;&#125;console.log(Object.prototype.toString.call(arr)) // [object Array]console.log(Object.prototype.toString.call(date)) // [object Date]console.log(Object.prototype.toString.call(fun)) // [object Function] 这种调用方式会直接调用Object原生的toString方法，避免了调用重写后方法导致结果不正确的问题。bind语法：与apply 语法相同区别：bind函数会创建一个新的函数，不会立即执行 123456789101112function Person() &#123; this.name = 'ipenman' this.sayHi = function()&#123; console.log(`My name is $&#123;this.name&#125;`) &#125;&#125;function Man() &#123; this.name = 'zhangsan'&#125;const man = new Man()const p = new Person()p.sayHi.bind(man)() // zhangsan call、apply、bind均以改变this的指向，p的this指向了man。 作为对象的方法12345678const Person = &#123; name: 'ipenman', age: 24, show: function() &#123; console.log(this) &#125;&#125;Person.show() // &#123; name: 'ipenman', age: 24, sayHi: [Function: sayHi] &#125; 当函数作为对象里的方法被调用时，它们的this指向的是调用该函数的对象。 箭头函数1函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象 this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this --《es6标准入门 阮一峰》 总结：1）全局环境下的this，在nodejs中是{}，实际指向的是module.exports这个模块作用域,浏览器指向的是Window。 2） 函数内的this 非严格模式下，函数内this的指向nodejs：global浏览器：window严格模式下，函数内this的指向nodejs：undefined浏览器：undefined 3） 构造函数的this，new关键字来声明的对象this指向的是它的实例。 4） call,apply,bind 函数改变的this，指向的是其函数内的指定参数。 5） 作为对象的方法，它们的this指向的是调用该函数的对象。 6）箭头函数的this，箭头函数的this指向的是外层代码块的this。]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Var&Let&Const]]></title>
    <url>%2F2020%2F01%2F13%2FVar-Let-Const%2F</url>
    <content type="text"><![CDATA[ES5只有全局作用域和函数作用域，没有块级作用域,这带来很多不合理的场景,比如内层变量可能覆盖外层变量，用来计数的循环变量泄露为全局变量，ES6引入了块级作用域来强化对变量生命周期的控制，新增了let和const两个命令，这两个命令的用法类似于var，但是又和var有所不同。 var和let/const的区别 变量声明提升 ： var声明的变量会提升到作用域的顶部，而let和const不会。 块级作用域： var声明的变量作用域范围是函数作用域，而let和const声明的变量作用域范围是块级作用域。 重复声明变量： var可以重复声明同一个变量，而let和const不会 var声明的全局变量会被挂载到顶层对象下面上，而let和const不会（浏览器环境顶层对象是: window，node环境顶层对象是: global） const命令两个注意点: 1、const 声明之后必须马上赋值，否则会报错。2、const 声明的常量，一旦声明则不能再次赋值，再次赋值会报错(复杂类型(数组、对象等)指针指向的地址不能更改，内部数据可以更，即更改对象属性不会，因为对象地址没有变)。 声明提升123456console.log(a); // 输出undefinedconsole.log(b); // 报错console.log(c); // 报错var a = 'abc';let b = 'ABC';const c = 123; 块级作用域123456789101112function foo() &#123; var flag = true; if(flag) &#123; var a = 'abc'; let b = 'ABC'; console.log(a); // 输出abc console.log(b); // 输出ABC &#125; console.log(a); // 输出abc console.log(b); // 报错&#125;foo(); 重复声明变量：123456var a = 'abc';var a;console.log(a); // 输出abclet b = 'ABC';let b;// 报错 挂载到全局变量：1234567var a = 'abc';let b = 'ABC';const c = 123;console.log(window.a); // 输出abcconsole.log(window.b); // 输出undefinedconsole.log(window.c); // 输出undefined const常量：简单类型不能改动： 12const c = 123;c = 345; // 报错 复杂类型：变量地址不能改变 12345678910const p = ['不能改动'];const p2 = &#123; name: 'OBKoro1'&#125;;p[0] = '不报错';p2.name = '不报错';p = ['报错'];p2 = &#123; name: '报错'&#125;; const所说的一旦声明值就不能改变，实际上指的是：变量指向的那个内存地址所保存的数据不得改动 简单类型(number、string、boolean)： 内存地址就是值,即常量(一变就报错). 复杂类型(对象、数组等)： 地址保存的是一个指针，const只能保证指针是固定的(总是指向同一个地址),它内部的值是可以改变的(不要以为const就安全了！)]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React源码解析之Component和PureComponent]]></title>
    <url>%2F2019%2F09%2F03%2FReact%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BComponent%E5%92%8CPureComponent%2F</url>
    <content type="text"><![CDATA[默认渲染行为在React Component的生命周期中，有一个shouldComponentUpdate方法，这个方法是用来控制组件是否被更新的，返回为true的话，则当props或state改变的时候进行更新，如果返回false，当props或state改变的时候不更新，默认返回值是true，这就意味着就算没有改变组件的props或state，也会导致组件的重绘。这就经常导致组件因为不相关数据的改变导致重绘，这极大的降低了React的渲染效率。（这里的更新不更新，其实说的是执不执行render函数，如果不执行render函数，那自然该组件和其子组件都不会重新渲染啦） 重写shouldComponentUpdate可以提升性能，它是在重新渲染过程开始欠触发的。当你明确知道组件不需要更新的时候，在该生命周期内返回false就行啦！ 比如下面的例子中，任何options的变化，甚至是其他数据的变化都可能导致所有cell的重绘。 1234//Table Component&#123;this.props.items.map(i =&gt; &lt;Cell data=&#123;i&#125; option=&#123;this.props.options[i]&#125; /&gt;)&#125; 重写shouldComponentUpdate的例子： 12345678910111213141516171819202122232425class CounterButton extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;count: 1&#125;; &#125; shouldComponentUpdate(nextProps, nextState) &#123; if (this.props.color !== nextProps.color) &#123; return true; &#125; if (this.state.count !== nextState.count) &#123; return true; &#125; return false; &#125; render() &#123; return ( &lt;button color=&#123;this.props.color&#125; onClick=&#123;() =&gt; this.setState(state =&gt; (&#123;count: state.count + 1&#125;))&#125; &gt; Count: &#123;this.state.count&#125; &lt;/button&gt; ); &#125;&#125; React.Component 与 React.PureComponent通常情况下，我们会使用ES6的class关键字来创建React组件： 123class MyComponent extends React.Component &#123; // some codes here ...&#125; 但是，你也可以创建一个继承React.PureComponent的React组件，就像这样: 123class MyComponent extends React.PureComponent &#123; // some codes here&#125; 那么，问题来了，这两种方式有什么区别呢？ 1.不能再重写shouldComponentUpdate，否则会引发警告(报错截图就不贴了，怪麻烦的) Warning: ListOfWords has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.2.继承PureComponent时，进行的是浅比较，也就是说，如果是引用类型的数据，只会比较是不是同一个地址，而不会比较具体这个地址存的数据是否完全一致 12345678910111213141516171819202122232425262728class ListOfWords extends React.PureComponent &#123; render() &#123; return &lt;div&gt;&#123;this.props.words.join(',')&#125;&lt;/div&gt;; &#125;&#125;class WordAdder extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; words: ['marklar'] &#125;; this.handleClick = this.handleClick.bind(this); &#125; handleClick() &#123; // This section is bad style and causes a bug const words = this.state.words; words.push('marklar'); this.setState(&#123;words: words&#125;); &#125; render() &#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;click&lt;/button&gt; &lt;ListOfWords words=&#123;this.state.words&#125; /&gt; &lt;/div&gt; ); &#125;&#125; 上面代码中，无论你怎么点击按钮，ListOfWords渲染的结果始终没变化，原因就是WordAdder的word的引用地址始终是同一个。 3.浅比较会忽略属性或状态突变的情况，其实也就是，数据引用指针没变而数据被改变的时候，也不新渲染组件。但其实很大程度上，我们是希望重新渲染的。所以，这就需要开发者自己保证避免数据突变。如果想使2中的按钮被点击后可以正确渲染ListOfWords，也很简单，在WordAdder的handleClick内部，将 const words = this.state.words; 改为const words = this.state.words.slice(0); 就行啦~（这时的words是在原来state的基础上复制出来一个新数组，所以引用地址当然变啦） 其他陷阱需要注意的是，还有一些小陷阱需要避免。 1.Literal Array与Literal Object 123&#123;this.props.items.map(i =&gt; &lt;Cell data=&#123;i&#125; options=&#123;this.props.options || []&#125; /&gt;)&#125; 若options为空，则会使用[]。[]每次会生成新的Array，因此导致Cell每次的props都不一样，导致需要重绘。解决方法如下: 1234const default = [];&#123;this.props.items.map(i =&gt; &lt;Cell data=&#123;i&#125; options=&#123;this.props.options || default&#125; /&gt;)&#125; 2.内联函数 函数也经常作为props传递，由于每次需要为内联函数创建一个新的实例，所以每次function都会指向不同的内存地址。比如： 123render() &#123; &lt;MyInput onChange=&#123;e =&gt; this.props.update(e.target.value)&#125; /&gt;;&#125; 以及： 123456update(e) &#123; this.props.update(e.target.value);&#125;render() &#123; return &lt;MyInput onChange=&#123;this.update.bind(this)&#125; /&gt;;&#125; 注意第二个例子也会导致创建新的函数实例。为了解决这个问题，需要提前绑定this指针： 12345678910constructor(props) &#123; super(props); this.update = this.update.bind(this); &#125; update(e) &#123; this.props.update(e.target.value); &#125; render() &#123; return &lt;MyInput onChange=&#123;this.update&#125; /&gt;; &#125; 源码解析Component部分： 1234567891011121314151617181920212223function Component(props, context, updater) &#123; this.props = props; this.context = context; this.refs = emptyObject; this.updater = updater || ReactNoopUpdateQueue; &#125;Component.prototype.isReactComponent = &#123;&#125;; //没有什么特别的用处Component.prototype.setState = function(partialState, callback) &#123; //setState用来更新组件的状态 //partialState 可以是对象，也可以是方法，在后续的react版本中会更多的推荐使用方法 invariant(//一个提醒，判断一下partialState是不是object或者function或者null，如果都不满足就给出下面的提醒，不是重要的代码 typeof partialState === 'object' || typeof partialState === 'function' || partialState == null, 'setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.', ); this.updater.enqueueSetState(this, partialState, callback, 'setState');//enqueueSetState在react-Dom里面&#125;;Component.prototype.forceUpdate = function(callback) &#123; this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');&#125;; PureComponent部分： 1234567891011121314function PureComponent(props, context, updater) &#123;//PureComponent可以认为是继承Component this.props = props; this.context = context; // If a component has string refs, we will assign a different object later. this.refs = emptyObject; this.updater = updater || ReactNoopUpdateQueue;&#125;const pureComponentPrototype = (PureComponent.prototype = new ComponentDummy());pureComponentPrototype.constructor = PureComponent;// Avoid an extra prototype jump for these methods.Object.assign(pureComponentPrototype, Component.prototype);//通过这么一个标识知道继承自这个类的组件来源于PureComponent，在后续的reactDom就会去判断是不是一个pureComponentPrototypepureComponentPrototype.isPureReactComponent = true;]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>React源码学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React源码解析之ReactElement]]></title>
    <url>%2F2019%2F08%2F29%2FReact%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BReactElement%2F</url>
    <content type="text"><![CDATA[学习react的源码，我们先从简单的ReactElement学起，ReactElement通过createElement创建的，JSX只是为React.createElement(component,props,…children)方法提供的语法糖。当我们写下一段JSX代码的时候，react是如何根据我们的JSX代码来生成虚拟DOM的组成元素element的？首先，它会经过babel 编译成React.createElement的表达式，戳这里演示。 reactElement的源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110//保留的propsconst RESERVED_PROPS = &#123; key: true, ref: true, __self: true, __source: true,&#125;;const ReactElement = function(type, key, ref, self, source, owner, props) &#123; const element = &#123; //是用来表示element的类型的，在此处就是标识为React元素 $$typeof: REACT_ELEMENT_TYPE, //元素的内置属性 type: type, key: key, ref: ref, props: props, //记录负责创建此元素的组建 _owner: owner, &#125;; if (__DEV__) &#123;/*...*/&#125; return element;&#125;export function createElement(type, config, children) &#123;//type是指节点类型,config是指节点上的一些属性，children指子节点 //初始化参数 let propName; const props = &#123;&#125;; let key = null; let ref = null; let self = null; let source = null;//如果存在config就提取里面的内容 if (config != null) &#123; //如果存在ref,key就赋值属性 if (hasValidRef(config)) &#123; ref = config.ref; &#125; if (hasValidKey(config)) &#123; key = '' + config.key; &#125; self = config.__self === undefined ? null : config.__self; source = config.__source === undefined ? null : config.__source; //复制config里的内容到props中,除了上面赋值的这些属性 for (propName in config) &#123; if ( hasOwnProperty.call(config, propName) &amp;&amp; !RESERVED_PROPS.hasOwnProperty(propName) ) &#123; props[propName] = config[propName]; &#125; &#125; &#125; //Children可以有多个，我们一般认为第三个参数以及之后的都是Children const childrenLength = arguments.length - 2; if (childrenLength === 1) &#123; props.children = children; &#125; else if (childrenLength &gt; 1) &#123; const childArray = Array(childrenLength); for (let i = 0; i &lt; childrenLength; i++) &#123; childArray[i] = arguments[i + 2]; &#125; if (__DEV__) &#123; if (Object.freeze) &#123; Object.freeze(childArray); &#125; &#125; //然后放在props内部，这样我们就可以通过this.props拿到了 props.children = childArray; &#125; // Resolve default props if (type &amp;&amp; type.defaultProps) &#123; const defaultProps = type.defaultProps; for (propName in defaultProps) &#123; if (props[propName] === undefined) &#123; props[propName] = defaultProps[propName]; &#125; &#125; &#125; if (__DEV__) &#123; if (key || ref) &#123; const displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type; if (key) &#123; defineKeyPropWarningGetter(props, displayName); &#125; if (ref) &#123; defineRefPropWarningGetter(props, displayName); &#125; &#125; &#125; return ReactElement( type, key, ref, self, source, ReactCurrentOwner.current, props, );&#125; 分析： ReactElement通过createElement创建，createElement函数数接收三个参数:type,config和children type指ReactElement的类型。 字符串比如div，p代表原生DOM，称为HostComponent Class类型是我们继承自Component或者PureComponent的组件，称为ClassComponent 方法就是functional Component 原生提供的Fragment、AsyncMode等是Symbol，会被特殊处理 TODO: 是否有其他的 config节点上的属性，但是要将key和ref作为单独的变量挂在ReactElement上，其他的config（剔除原型链上的属性和规定要剔除的属性）丢到 props 中去。 12let app = (&lt;div id='app'&gt;Hello World!&lt;/div&gt;);console.log(app) 打印结果： 注意：$$typeof在这里是一个常量：REACT_ELEMENT_TYPE，标识为react元素，但有一个特例：ReactDOM.createPortal的时候是REACT_PORTAL_TYPE，不过他不是通过createElement创建的，所以他应该也不属于ReactElementReactElement只是一个用来承载信息的容器，他会告诉后续的操作这个节点的以下信息： type类型，用于判断如何创建节点key和ref这些特殊信息props新的属性内容$$typeof用于确定是否属于ReactElement这些信息对于后期构建应用的树结构是非常重要的，而React通过提供这种类型的数据，来脱离平台的限制 流程图总结：]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>React源码学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React API]]></title>
    <url>%2F2019%2F08%2F29%2FReact-API%2F</url>
    <content type="text"><![CDATA[将react作为核心架构的人很多，但其实很多人都不知道react到底是个什么东东。如果你去看源码会发现，react的源码只有1000多行，儿react-dom却有近2W行，你的眼睛是好的，没有看错，大部分的架构逻辑都在react-dom当中，那么react到底是个什么东东呢？？？ 注意：我贴的代码都是16版本以后的。 我们先来看一下React暴露出来的API。 123456789101112131415161718192021222324252627282930313233//packages/react/src/React.js//声明一个react对象const React = &#123; Children: &#123; map, forEach, count, toArray, only, &#125;, createRef, Component, PureComponent, createContext, forwardRef, lazy, memo, Fragment: REACT_FRAGMENT_TYPE, StrictMode: REACT_STRICT_MODE_TYPE, Suspense: REACT_SUSPENSE_TYPE, createElement: __DEV__ ? createElementWithValidation : createElement, cloneElement: __DEV__ ? cloneElementWithValidation : cloneElement, createFactory: __DEV__ ? createFactoryWithValidation : createFactory, isValidElement: isValidElement, version: ReactVersion, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: ReactSharedInternals,&#125;; Children这个对象提供了一堆帮你处理props.children的方法，因为children是一个类似数组但不是数组的数据结构，如果要对其进行处理，可以使用React.Children外挂的方法。 createRef新的ref用法，React即将抛弃这种string ref的用法，将来你只能使用两种方法来使用ref 123456789101112class App extends React.Component&#123; constructor() &#123; this.ref = React.createRef() &#125; render() &#123; return &lt;div ref=&#123;this.ref&#125; /&gt; // or return &lt;div ref=&#123;(node) =&gt; this.funRef = node&#125; /&gt; &#125;&#125; Component&amp;PureComponent 这两个类基本相同，唯一的区别是PureComponent 的原型上多了一个标识。12345if (ctor.prototype &amp;&amp; ctor.prototype.isPureReactComponent) &#123; return ( !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) );&#125; 这是检查组件是否需要更新的一个判断，ctor就是你声明的继承自Component or PureComponent的类，他会判断你是否继承自PureComponent，如果是的话就shallowEqual比较state和props。 注意：React中对比一个ClassComponent是否需要更新，只有两个地方。一是看有没有shouldComponentUpdate方法，二就是这里的PureComponent判断createContextcreateContext是官方定稿的context方案，在这之前我们一直在用的老的context API都是React不推荐的API，现在新的API释出，官方也已经确定在17大版本会把老API去除。 新API的使用方法： 12345678910111213const &#123; Provider, Consumer &#125; = React.createContext('defaultValue')const ProviderComp = (props) =&gt; ( &lt;Provider value=&#123;'realValue'&#125;&gt; &#123;props.children&#125; &lt;/Provider&gt;)const ConsumerComp = () =&gt; ( &lt;Consumer&gt; &#123;(value) =&gt; &lt;p&gt;&#123;value&#125;&lt;/p&gt;&#125; &lt;/Consumber&gt;) 后面讲context会专门比较新老的API的差异，提前说一句，老API的性能不是一般的差 forwardRefforwardRef是用来解决HOC组件传递ref的问题的，所谓HOC就是Higher Order Component，比如使用redux的时候，我们用connect来给组件绑定需要的state，这其中其实就是给我们的组件在外部包了一层组件，然后通过…props的方式把外部的props传入到实际组件。forwardRef的使用方法如下： 123const TargetComponent = React.forwardRef((props, ref) =&gt; ( &lt;TargetComponent ref=&#123;ref&#125; /&gt;)) 这也是为什么要提供createRef作为新的ref使用方法的原因，如果用string ref就没法当作参数传递了。 这里只是简单说一下使用方法，后面讲ref的时候会详细分析。 类型1234Fragment: REACT_FRAGMENT_TYPE,StrictMode: REACT_STRICT_MODE_TYPE,unstable_AsyncMode: REACT_ASYNC_MODE_TYPE,unstable_Profiler: REACT_PROFILER_TYPE, 这四个都是React提供的组件，但他们呢其实都只是占位符，都是一个Symbol，在React实际检测到他们的时候会做一些特殊的处理，比如StrictMode和AsyncMode会让他们的子节点对应的Fiber的mode都变成和他们一样的mode createElement &amp; cloneElement &amp; createFactory &amp; isValidElementcreateElement可谓是React中最重要的API了，他是用来创建ReactElement的，但是很多同学却从没见过也没用过，这是为啥呢？因为你用了JSX，JSX并不是标准的js，所以要经过编译才能变成可运行的js，而编译之后，createElement就出现了： 1234567891011121314// jsx&lt;div id="app"&gt;content&lt;/div&gt;// jsReact.createElement('div', &#123; id: 'app' &#125;, 'content')cloneElement就很明显了，是用来克隆一个ReactElement的createFactory是用来创建专门用来创建某一类ReactElement的工厂的，export function createFactory(type) &#123; const factory = createElement.bind(null, type); factory.type = type; return factory;&#125; 他其实就是绑定了第一个参数的createElement，一般我们用JSX进行编程的时候不会用到这个API isValidElement顾名思义就是用来验证是否是一个ReactElement的，基本也用不太到]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>React源码学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写在react源码学习前的破烂话]]></title>
    <url>%2F2019%2F08%2F29%2F%E5%86%99%E5%9C%A8react%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E5%89%8D%E7%9A%84%E7%A0%B4%E7%83%82%E8%AF%9D%2F</url>
    <content type="text"><![CDATA[看react的源码这个事情，我从2018年就开始计划，但是到2019年的9月份，这个事情依然是断断续续的，看了一些也是一知半解的，有时候我觉得自己才入门，但是有时候我又觉得自己没有入门，反正不管有没有入门，爱过还是恨过，过去的就过去吧，以前的就算翻篇了，从现在开始一步一步的重新来过，我会边看边总结下来的，和我一起来对react’爱爱～爱不完。。。’，忽然想起一句歌词，‘我想要和你谈恋爱，这算不算表白，想要拉着你的手，再也不放开。。。’，有点扯哈，继续往下唠。 我们为什么要学习react的源码呢？当然是因为太闲了呗～～～。开玩笑哈，其实看源码会有很多好处，首先，可以提高自身价值，开发能力，解决问题的能力，最主要的是可以升职加薪是不是呀？其次，可以提升你的学习能力，思考能力，设计能力等等好处。 react是一个很有重量的框架，深受国内大公司的青睐，它的核心API就是setState,带来了很纯粹的开发体验。Fiber从根本上解决了js单线程运行如果计算量太大的话导致卡顿的问题。 学习源码需要必备： 足够的耐心 思考思考再思考 善于提问和笔记 毕竟看源码不是看小说，不会用大白话给你写出来，它会比较枯燥，你需要有一定的耐心，要善于思考，多多总结，在接触一些新事物之前，最大的困难不是不理解，而是不知道，对于一个新概念，如果你不知道，那么你完全不会对它产生任何疑问，只有知道这个东西，并且开始想要理解的时候，才会产生各种各样的问题，去思考，去解决，就会收获，接下来让我们带着这样的❤️去开启源码学习之旅吧。]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>React源码学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[继承]]></title>
    <url>%2F2019%2F08%2F20%2F%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[什么是继承？就是获取存在对象已有属性和方法的一种方式。 由于函数没有签名，在 ECMAScript 中无法实现接口继承，因此，ECMAScript只支持实现继承，而实现继承主要是依靠原型链实现的，基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。 简单的回顾一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。 原型链继承1234567891011121314151617181920212223242526272829303132333435363738// 创建父构造函数function Father()&#123; this.name = 'xiaobai'; this.age = 16; this.showName = function()&#123; console.log(this.name); &#125;;&#125;;// 设置父构造函数的原型Father.prototype.friends = ['小红', '小蓝'];Father.prototype.showAge = function()&#123; console.log(this.age);&#125;;// 创建子构造函数function Son()&#123;&#125;;// 实现继承//此时把Son的原型重写了,换成了Father的实例//换句话说,原来存在Father的实例中的属性和方法,现在也存在Son.prototype中了Son.prototype = new Father();// 修改子构造函数的原型的构造器属性Son.prototype.constructor = Son;var child = new Son();console.log(child.name); // xiaobaiconsole.log(child.age);// 16child.showName();// xiaobaichild.showAge();// 16console.log(child.friends); // ["小红", "小蓝"]// 当我们改变friends的时候, 父构造函数的原型对象的也会变化child.friends.push('小王');console.log(child.friends);["小红", "小蓝", "小王"]var father = new Father();console.log(father.friends);["小红", "小蓝", "小王"]console.log(child instanceof Father);//true instanceof判断元素是否在另一个元素的原型链上console.log(child); 概念： 子类构造函数的原型对象等于父类构造函数的实例，即子构造函数.prototype = new 父构造函数() 优点： 实例可继承的属性有：实例的构造函数的属性，父类构造函数属性，父类原型的属性。 缺点： 1、新实例无法向父类构造函数传参。 2、所有新实例都会共享父类实例的属性。（原型上的属性是共享的，一个实例修改了原型属性，另一个实例的原型属性也会被修改！） 借用构造函数继承（有时候也叫做伪造对象或经典继承）12345678910111213141516171819202122// 创建父类构造函数function Person(name)&#123; this.name = name; this.friends = ['小王', '小强']; this.showName = function()&#123; console.log(this.name); &#125;;&#125;;Person.prototype.age = 18;// 创建子构造函数 function Son(name)&#123; // 使用call借用Person的构造函数，会在Son对象上执行父类函数中定义的所有对象初始化代码，S子类函数的每个实例就都会具有自己的 属性的副本。 Person.call(this, name); &#125; // 测试是否有了 Person 的成员 var son1 = new Son('Li'); son1.showName(); // Li console.log(son1.friends); // ['小王','小强'] console.log(son1.age)//undefined 使用call和apply借用其他构造函数的成员,可以解决给父构造函数传递参数的问题, 但是获取不到父构造函数原型上的成员,也不存在共享问题。 概念： 用.call()和.apply()在子类函数中调用父类构造函数。 优点： 只继承了父类构造函数的属性，没有继承父类原型的属性。 解决了原型链继承缺点。 可以继承多个构造函数属性（call多个）。 在子实例中可向父实例传参。 缺点： 只能继承父类构造函数的属性。 无法实现构造函数的复用。（每次用每次都要重新调用）。 每个新实例都有父类构造函数的副本，臃肿。 组合继承（伪经典继承）常用12345678910111213141516171819202122232425262728293031323334353637// 创建父构造函数function Person(name,age)&#123; this.name = name; this.age = age; this.colors = ["red","green","blue"]; this.showName = function()&#123; console.log(this.name); &#125;;&#125;;// 设置父构造函数的原型对象Person.prototype.showAge = function()&#123; console.log(this.age);&#125;;// 创建子构造函数function Student(name,age)&#123; Person.call(this,name); //第二次调用 Person()，当调用 Student 构造函数时，又会调用一次 Person 构造函数，这一次又在新对象上创建了实例属性 name ，age,colors和showName。于是，这两个属性就屏蔽了原型中的同名属性。 this.age = age;&#125;;// 设置继承Student.prototype = new Person(); //第一次调用 Person(),得到三个属性name,age,colors和一个方法showName，它们都是Person的属性，只不过现在位于Student的原型中。Student.prototype.constructor = Student;Student.prototype.sayAge = function()&#123; console.log(this.age);&#125;;var stu1 = new Student('xiaobai',16);stu1.colors.push('black');console.log(stu1.colors); //["red", "green", "blue", "black"]stu1.showName(); //xiaobaistu1.showAge(); //16stu1.sayAge(); //16var stu2 = new Student('xiaohong',18);console.log(stu2.colors); //["red", "green", "blue"]stu2.showName(); //xiaohongstu2.showAge(); //18stu2.sayAge(); //18 概念： 使用原型链实现对原型属性和方法的继承，而通过构造函数来实现对实例属性的继承。 特点： 可以继承父类原型上的属性，可以传参，可复用。 每个新实例引入的构造函数属性是私有的。 instanceof 和 isPrototypeOf()也能够用于识别基于组合继承创建的对象。 缺点：调用了两次父类构造函数（耗内存）:一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。子类的构造函数会代替原型上的那个父类构造函数。 原型式继承(借用构造函数的原型对象实现继承)1234567891011121314151617181920212223242526272829// 创建父构造函数function SuperClass(name)&#123; this.name = name; this.showName = function()&#123; console.log(this.name); &#125;&#125;// 设置父构造器的原型对象SuperClass.prototype.age = 25;SuperClass.prototype.friends = ['小名','小丽'];SuperClass.prototype.showAge = function()&#123; console.log(this.age);&#125;// 创建子构造函数, 刚开始没有任何成员function SubClass()&#123;&#125;// 设置子构造器的原型对象实现继承SubClass.prototype = SuperClass.prototype;// 因为子构造函数的原型被覆盖了, 所以现在子构造函数的原型的构造器属性已经不在指向SubClass,// 而是SuperClass,我们需要修正console.log(SubClass.prototype.constructor == SuperClass);// trueconsole.log(SuperClass.prototype.constructor == SuperClass);// trueSuperClass.prototype.constructor = SubClass;// 上面这行代码之后, 就实现了继承var child = new SubClass();console.log(child.name);//undefinedconsole.log(child.age);// 25console.log(child.friends);// ['小名','小丽']child.showAge();// 25 123456789101112131415161718192021//红宝书的例子function object(o)&#123; function F()&#123;&#125;; //创建临时性的构造函数（对象） F.prototype = o; //浅复制，只将地址进行复制 return new F();&#125;var person = &#123; name: "Nicholas", friends: ["Shelby", "Court", "Van"]&#125;;var anotherPerson = object(person);anotherPerson.name = "Greg"; //直接在anotherPerson里面创建name（基本类型），再进行赋值anotherPerson.friends.push("Rob");//在anotherPerson查找friends属性（引用类型），没有找到则顺着原型向上（即继承的父类型）找，直到找到，否则报undefindvar yetAnotherPerson = object(person);yetAnotherPerson.name = "Linda";yetAnotherPerson.friends.push("Barbie");//anotherPerson和yetAnotherPerson共享享friends属性alert(person.friends); //"Shelby,Court,Van,Rob,Barbie" 概念： 借助原型可以基于已有的的对象创建新对象，即如在一个函数Object内部，先创建一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型（实际上执行了浅复制），最后返回这个临时类型的新实例。object.create()就是这个原理。 12345678910111213//Object.create()var Person = &#123; name:'小白'; friends:['小红'，'小蓝'];&#125;;var otherPerson = Object.create(Person,&#123; name:&#123; value:'小紫' &#125;&#125;);console.log(otherPerson.name);//小紫 特点： 类似于复制一个对象，用函数来包装。 缺点： 所有实例都会继承原型上的属性。 无法实现复用。（新实例属性都是后面添加的） 父构造函数的原型对象和子构造函数的原型对象上的成员有共享问题只能继承父构造函数的原型对象上的成员,不能继承父构造函数的实例对象的成员 寄生式继承1234567891011121314151617181920function content(obj)&#123; function Fn()&#123;&#125;; Fn.prototype = obj; // 继承了传入的参数 return new Fn();//返回函数对象&#125;;var sup = new Person();//以上是原型式继承，给原型式继承再套个壳子传递参数function subobject(obj)&#123; var sub = content(obj); sub.name = 'gar'; return sub;&#125;;var sup2 = subobject(sup);//这个函数经过声明之后就成了可添属性的对象console.log(typeof subobject);//functionconsole.log(typeof sup2);//objectconsole.log(typeof sup2.name);//gar返回了个sub对象，继承了sub的属性 123456789101112131415161718192021function object(o)&#123; function F()&#123;&#125;; //创建临时性构造函数（对象） F.prototype = o; //浅复制（只将地址进行赋值） return new F();&#125;;function createAnother(original)&#123; var clone = object(original); //通过调用函数创建一个新对象 clone.sayHi = function()&#123; //以某种方式来增强这个对象 console.log('Hi'); &#125;; return clone; //返回这个对象&#125;;var person = &#123; name:"xiaoxiao", friends:['小白','小灰','小蓝']&#125;;var anotherPerson = createAnother(person);anotherPerson.sayHi(); //Hi 概念： 就是给原型式继承外面套了个壳子。 优点： 没有创建自定义类型，因为只是套了个壳子返回对象（这个），这个函数顺理成章就成了创建的新对象。 缺点： 没用到原型，无法复用。 寄生组合式继承（常用）寄生：在函数内返回对象然后调用 组合：1、函数的原型等于另一个实例。2、在函数中用apply或者call引入另一个构造函数，可传参 123456789101112131415161718192021222324//寄生function content(obj)&#123; function Fn()&#123;&#125;; Fn.prototype = obj; return new Fn();&#125;;//content就是Fn实例的另一种表示方法var con = content(Person.prototype);//con实例（Fn实例）的原型继承了父类函数的原型//上述更像时原型链继承，只不过只继承了原型属性//组合function Sub()&#123; Person.call(this);//这个继承了父类构造函数的属性&#125;;//解决了组合式两次调用构造函数属性的缺点//重点Sub.prototype = con;//继承了con实例con.constructor = Sub;//一定要修复实例var sub1 = new Sub();//Sub的实例就继承了构造函数属性，父类实力，con的函数属性console.log(sub1.age);//18 12345678910//上述和以下例子的效果是一样的function Fn()&#123;&#125;;Fn.prototype = Person.prototype;function Sub()&#123; Person.call(this);di&#125;;Sub.prototype = new Fn();var sub2 = new Sub();console.log(sub2.age);//18 概念： 通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。 基本思想： 没有必要为了指定子类型的原型而调用父类型的构造函数（函数复用），我们需要的是父类型原型的副本。 本质： 使用寄生式继承来继承父类型的原型，然后再将结果指定给子类型的原型。 优点： 修复了组合继承的问题 12345function inheritPrototype(subType, superType) &#123; var prototype = object(superType.prototype); //创建对象 prototype.constructor = subType; //增强对象 subType.prototype = prototype; //指定对象&#125; 在函数内部，第一步是创建父类型原型的一个副本。 第二步是为创建的副本添加 constructor 属性，从而弥补因重写原型而失去的默认的 constructor 属性。 最后一步，将新创建的对象（即副本）赋值给子类型的原型。这样，我们就可以用调用 inheritPrototype()函数的语句，去替换前面例子中为子类型原型赋值的语句了 123456789101112131415161718192021222324252627282930313233343536373839404142function object(o)&#123; function F()&#123;&#125;; //创建临时性构造函数（对象） F.prototype = o; //浅复制（只将地址进行赋值） return new F();&#125;;function inheritPrototype(subType, superType) &#123; var prototype = object(superType.prototype); //创建对象，使用寄生式继承来继承父类的原型 prototype.constructor = subType; //增强对象 subType.prototype = prototype; //指定对象，将结果指定给子类型的原型&#125;;function SuperType(name)&#123; this.name = name; this.colors = ["red", "blue", "green"];&#125;;SuperType.prototype.sayName = function()&#123; alert(this.name);&#125;;function SubType(name, age)&#123; SuperType.call(this, name); //借用构造函数来继承属性 this.age = age;&#125;;inheritPrototype(SubType, SuperType);//使用寄生式来继承方法SubType.prototype.sayAge = function()&#123; console.log(this.age);&#125;;var instance1 = new SubType("Nicholas", 29);instance1.colors.push("black");console.log(instance1.colors); //"red,blue,green,black"instance1.sayName(); //"Nicholas";instance1.sayAge(); //29var instance2 = new SubType("Greg", 27);console.log(instance2.colors); //"red,blue,green"instance2.sayName(); //"Greg";instance2.sayAge(); //27 继承这些知识点与其说是对象的继承，更像是函数的功能用法，如何用函数做到复用，组合，这些和使用继承的思考是一样的。上述几个继承的方法都可以手动修复他们的缺点，但就是多了这个手动修复就变成了另一种继承模式。 这些继承模式的学习重点是学它们的思想，不然你会在coding书本上的例子的时候，会觉得明明可以直接继承为什么还要搞这么麻烦。就像原型式继承它用函数复制了内部对象的一个副本，这样不仅可以继承内部对象的属性，还能把函数（对象，来源内部对象的返回）随意调用，给它们添加属性，改个参数就可以改变原型对象，而这些新增的属性也不会相互影响。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>Object</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型链]]></title>
    <url>%2F2019%2F08%2F19%2F%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[如果说上次说原型就让你吐血了，那这篇原型链可能让你马上气绝身亡。 哈哈哈。。。其实原型链这个家伙，说难很难，说简单也简单，接下来就让我来说道说道，准备好救心丸！！！！原型链的顶层就是Object.prototype，而这个对象的是没有原型对象的，在chrome控制台中输入Object.__proto__，输出是ƒ () { }，一个空的函数。 原型链思考：如果我们让一个原型对象等于另外一个构造函数的实例，结果会怎样？代码： 123456789101112131415161718192021function A()&#123; this.name = 'qiaoqiao';&#125;;A.prototype.getName = function()&#123; return this.name;&#125;function B()&#123; this.age = 18;&#125;;//继承B.prototype = new A();B.prototype.getAge = function()&#123; return this.age;&#125;;var C = new B();console.log(C.getName()); // qiaoqiao 分析： 原型链的概念：就是依赖对象的__proto__的指向，当查找实例自身不存在的属性时，就一层层的往创建对象的构造函数上查找，直至到Object时，就没有__proto__指向了。 简单的分析： 12345function Person(name)&#123; this.name = name; &#125; var p = new Person();//p ---&gt; Person.prototype ---&gt;Object.prototype----&gt;null 属性查找规则: 当访问一个对象的属性的时候，会先在自身查找有没有,如果找到直接使用，如果没有找到，则去原型链指向的对象的构造函数的prototype中找，找到直接使用，没找到就返回undifined或报错。 事实上前面的例子中少了一环，所有引用类型默认都继承了Object,而这个继承是通过原型链继承实现的，只需要记住：所有函数的默认原型都是Object的实例，因此默认原型都会包含一个内部指针，指向Object.prototype。这也正是所有自定义类型都会继承toString()、valueOf()等默认方法的根本原因。 例子中完整的原型链： 确定原型和实例的关系： 第一种方法：使用instanceof操作符。 123console.log(C instanceOf Object); //trueconsole.log(C instanceOf A); //trueconsole.log(C instanceOf B); //true 第二种方法：使用isPrototyepOf()方法。 123console.log(Object.prototype.isPrototypeOf(C)); //trueconsole.log(A.prototype.isPrototypeOf(C)); //trueconsole.log(B.prototype.isPrototypeOf(C)); //true 由于原型链的关系，C是Object、A或B中任何一个类型的实例。 注意：在通过原型链实现继承时，不能使用对象字面量创建原型方法。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>Object</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型]]></title>
    <url>%2F2019%2F08%2F16%2F%E5%8E%9F%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[对于初学者来说，JavaScript的原型是一件让人头疼甚至吐血的事情，prototype和__proto__又让人傻傻分不清，虽然网上有很多相关资料，还有一张经典的图，线条很多，看的就头疼，更甚者吐血身亡，就算是对于“老人”，也不好整明白呀，或者好不容易搞清楚了，过几天又忘了（我就是这样，嘿嘿）。接下来请允许我尽可能形象生动的来阐述明白，哈哈哈哈哈。。。 理解原型对象prototype 和 __proto__ ？prototype是只有函数才会有的属性；而__proto__是所有对象（除了 null）都有的属性。几乎所有的函数都有一个prototype属性，这个属性指向函数的原型对象，prototype上挂载的所有属性和方法都可以被这个函数的实例继承。 不管什么时候，只要你创建了一个函数，它就会具有prototype属性，这个属性指向函数的原型对象。默认情况下所有的对象都会又一个constructor(构造函数属性)，这个属性指向prototype属性所在函数的指针。emm~ 是不是看晕了？没关系，让我们来点代码和配图，你可以直接吐了。 1234function Person()&#123;&#125;; //这个是一个构造函数Person.prototype //这个是函数的原型对象var person1 = new Person(); // 调用构造函数创建的实例var person2 = new Person(); // 调用构造函数创建的实例 代码分析：创建了一个自定义的构造函数之后，其原型对象默认会取得一个constructor属性，Person.prototype.constructor指向的是Person,当调用一个构造函数创建一个实例之后，该实例的内部就会有一个指针__proto__（内部属性[[Prototype]]）,指向构造函数的原型对象，这个连接存在于实例与构造函数的原型对象之间，而不是实例与构造函数之间。 123Person.prototype===person1.__proto__ //trueperson1.__proto__.constructor === person1.constructor===Person // truePerson.constructor===Function // true 扩展：如果[[Prototype]]指向调用isPrototype()方法的对象）（Person.prototype），那么这个方法就会返回true。 12console.log(Person.prototype.isPrototypeOf(person1)); // true console.log(Person.prototype.isPrototypeOf(person2)); // true ECMAScript5 增加了一个新方法 Object.getPrototypeOf()。 1console.log(Object.getPrototypeOf(person1) === Person.prototype); // true 怎么样？你还行吗？还行的话来张经典图片，嘿嘿。。 总结一下 prototype 和proto到底是什么关系呢? 函数对象的 prototype 属性, 可以称之为显式原型属性(简称: 显式原型) 实例对象的proto属性, 可以称之为隐式原型属性(简称: 隐式原型) 原型对象: 也就是 prototype 属性和proto属性指向的对象 自有属性和原型属性每当代码读取某个对象的某个属性时，都会执行一次搜索，搜索顺序是先自有属性然后原型属性。即先从对象实例本身开始，如果在实例中找到了这个属性就返回对应的值，如果没有找到则再到原型对象上查找，查找到就该属性的值，若是没有的话就返回undefind.下面来举个例子说明： 12345678910function Person()&#123;&#125;Person.prototype.name = '乔乔';Person.prototype.age = 16;Person.prototype.job = 'web前端工程师';Person.prototype.sayName = function()&#123; alert(this.name);&#125;;var person1 = new Person();person1.sayName(); //'乔乔'; 分析：在我们调用person1.sayName()的时候，会执行两次搜索。解析器：“实例person1有sayName属性吗？”答：“没有”解析器：“person1的原型有sayName属性吗”答：“有”于是，就读到原型对象中的函数。 扩展：原型最初只包含constructor属性，而该属性也是共享的，因此可以通过对象实例访问。！注意 可以通过对象实例访问保存在原型中的值，但不能通过对象实例重写原型中的值。 实例和原型中的属性同名时，该属性会自动屏蔽原型中的属性，选择实例中的属性，不过使用detele操作符可以完全删除实例属性，从而从新访问原型中的属性。 使用hasOwnPrototy()方法可以检测一个属性是否存在于实例中，若实例中存在，则返回true。如果我们想要知道某个属性是否在原型上，就需要自己写一个函数： const hasPrototypeProperty=(obj,key)=&gt;(key in obj)&amp;&amp;(!obj.hasOwnProperty(key))代码： 123456789101112131415161718192021function Person()&#123;&#125;;Person.prototype.name = 'qiaoqiao';Person.prototype.age = 18;Person.prototype.job = '前端';Person.prototype.sayName = function()&#123; console.log(this.name)&#125;;var person1 = new Person();var person2 = new Person();person1.name = 'xiaomin';console.log(person1.name); //xiaomin 来自实例console.log(person2.name);//qiaoqiao 来自原型console.log(person1.hasOwnPrototy(name));//trueconsole.log(person2.hasOwnPrototy(name));//falsedetele person1.name;console.log(person1.name);//qiaoqiao 来自原型 扩展：Object.getOwnPropertyDescriptor()方法只能用于实例属性。更多请自行百度哟！！原型与in操作两种方法：单独使用：无论是存在于实例中还是原型中，只要能访问到就会返回true。for-in循环中使用:返回所有能够通过对象访问的、克枚举的属性，屏蔽了原型中的不可枚举的属性。 Object.keys()方法接受一个对象作为参数，返回一个包含所有可枚举实例属性的字符串数组。Object.getOwnPropertyNames()方法可以得到所有的实例属性，无论是否可枚举。 12345678function Person()&#123;&#125;;Person..prototype.name = 'qiaoqiao';var person1 = new Person();person1.hobby = 'comic';console.log("name" in person1) ; //trueconsole.log("hobby" in person1) ; //true 实例对象之间的关系12345678910function Person()&#123;&#125;;const person1=new Person();const person2=new Person();person1==person2; // false,这是因为在这里都指向不同的内存，&#123;&#125;===&#123;&#125; // falseJSON.stringify(person1)===JSON.stringify(person2); // trueperson1.constructor===person2.constructor; // true 这里的构造函数都指向Person，所以为trueperson1.__proto__===person2.__proto__ ;// 当然这个也为trueperson1.__proto__===Person.prototype ;// trueObject.getPrototypeOf(person1)===Object.getPrototypeOf(person2) ;// true 相关的原型语法前面的例子中，原型的属性都是通过Person.prototype一个一个添加上去的，原型对象的constructor指向构造函数，其实也可以使用对象的字面量来重写整个原型的对象，但是重写之后的constructor已经不再指向构造函数，而是指向Object。 123456789101112function Person()&#123;&#125;;Person.prototype = &#123; name:'qiaoqiao', age:16&#125;var obj = new Person();console.log(obj instanceof Object); // trueconsole.log(obj instanceof Person); // trueconsole.log(obj.constructor == Person); // falseconsole.log(obj.constructor == Object); // true 虽然用instanceof操作符测试Object和Person仍然返回true，但是constuctor属性则等于Object而不等于Person了。如果constructor的值很重要的话，可以通过一下方式设置： 1234567function Person()&#123;&#125;;Person.prototype = &#123; constructor:Person, name:'qiaoqiao', age:16&#125; 重写原型对象会切断现有原型与任何之前已经存在的对象实例之间的联系，它们的引用依然是最初的原型。 1234567891011121314function Person()&#123;&#125;;var obj = new Person();Person.prototype = &#123; name:'qiaoqiao', age:16, job:'前端', sayName:function()&#123; console.log(this.name); &#125;;&#125;;obj.sayName(); // error prototype是js面向对象的一个重要机制，说难很难，说简单也简单，原型链最终指向null,然而null究竟代表了什么呢？引用阮一峰老师的 《undefined与null的区别》 就是： null 表示“没有对象”，即该处不应该有值。所以 Object.prototype.proto 的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。 所以查找属性的时候查到 Object.prototype 就可以停止查找了。 首先要明确：函数（Function）才有prototype属性，对象（除Object）拥有__proto__。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>Object</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象的程序设计模式]]></title>
    <url>%2F2019%2F08%2F15%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[工厂模式工厂模式是软件工程领域一种广为认知的设计模式。工厂模式虽然解决了创建多个对象的问题，但却没有解决对象的识别问题（即怎样知道一个对象的类型）。 12345678910111213function createPerson(name,age,job)&#123; var obj = new Object(); obj.name = name; obj.age = age; obj.job = job; obj.sayName = function()&#123; alert(this.name); &#125;; return obj;&#125;;var person1 = createPerson('乔乔',16,'web前端工程师')；var person2 = createPerson('小敏',18,'web前端工程师')； 构造函数模式可以创建原生构造函数也可以创建自定义的构造函数。 1234567891011function Person(name,age,job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = function()&#123; alert(this.name); &#125;;&#125;var person1 = new Person('乔乔',16,'web前端工程师');var person2 = new Person('小敏',18,'web前端工程师'); 与工厂模式相比，部分代码相同，不同之处： 没有显示的创建对象； 直接将属性和方法赋给了this对象； 没有return语句。 按照惯例，构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头。 对象有一个constructor(构造函数)属性，最初是用来标识对象类型的，该属性指向构造函数。上述例子中的person1和person2的constructor指向Person。 123456console.log(person1.constructor == Person); //trueconsole.log(person2.constructor == Person); //trueconsole.log(person1 instanceof Object); //trueconsole.log(person1 instanceof Person); //trueconsole.log(person2 instanceof Object); //trueconsole.log(person2 instanceof Person); //true 使用new操作会经历以下4个步骤： 创建一个新对象； 将构造函数的作用域赋给新对象（因此this就指向这个新对象）； 执行构造函数中的代码（为这个新对象添加属性） 返回新对象。 将构造函数当作函数构造函数也是函数，通过new操作符调用的话，就是构造函数，不通过new操作符调用的话就是普通函数。以前面的例子为例： 当作构造函数使用 12var person = new Person('乔乔',16,'web前端工程师');person.sayName(); //'乔乔' 作为普通函数调用 12Person('乔乔',16,'web前端工程师');window.sayName(); //'乔乔'; 在另一个对象的作用域中调用 123var obj = new Object();Person.call(obj,'乔乔',16,'web前端工程师');obj..sayName(); //'乔乔'; 构造函数的问题缺点：每个方法都要在每个实例上重新创建一边，因为函数是对象，因此每定义一个函数，也就是实例化了一个对象。以这种方式创建函数，会导致不同的作用域链和标识符解析，但创建Function新实例的机制依然是相同的，因此不同函实例上的同名函数是不相等的。 1console.log(person1.sayName == person2.sayName); //false 可以通过把函数定义装一刀构造函数外部来解决这个问题。 12345678910111213function Person(name,age,job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = sayName;&#125;;function sayName()&#123; alert(this.name);&#125;;var person1 = new Person('乔乔',16,'web前端工程师');var person2 = new Person('小敏',18,'web前端工程师'); 这样通过定义一个全局的函数，解决了两个函数做同一件事的问题，但是又会有新的问题：如果对象需要定义很多方法，那么就要定义很多个全局函数。这个问题可以通过使用原型模式来解决。 原型模式我们创建的每一个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法（好处）。 1234567891011121314151617function Person()&#123;&#125;Person.prototype.name = '乔乔';Person.prototype.age = 16;Person.prototype.job = 'web前端工程师';Person.prototype.sayName = function()&#123; alert(this.name);&#125;;var person1 = new Person();person1.sayName(); //'乔乔';var person2 = new Person();person2.sayName(); //'乔乔';console.log(person1.sayName() == person2.sayName()); //true 由此可以看出，person1和person2访问的都是同一组属性和同一个sayName()函数。 组合使用构造函数模式和原型模式这是创建自定义类型的最常见方式，构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。每个实例都会有自己实例属性的一份副本，但同时又共享着对方法的引用，最大限度地节省了内存。 1234567891011121314151617181920212223function Person(name,age,job)&#123; this.name = name; this.age = age; this.job = job; this.friends = ["许大敏","游小敏"];&#125;;Person.prototype = &#123; constructor:Person, sayName:function()&#123; alert(this.name); &#125;&#125;var person1 = new Person('乔乔',16,'web前端工程师');var person2 = new Person('小敏',18,'web前端工程师');person1.friends.push("乔小小");console.log(person1.friends); //["许大敏","游小敏","乔小小"]console.log(person2.friends); //["许大敏","游小敏"]console.log(person1.friends == person2.friends); //false console.log(person1.sayName == person1.sayName); //true 动态原型模式把所有信息都封装在构造函数中，通过在构造函数初始化原型（在必要的情况下），换句话说，可以通过检查某个存放的方法是否有效，来决定是否初始化原型。 123456789101112131415function Person(name,age,job)&#123; this.name = name; this.age = age; this.job = job; //方法,也可以使用instanceof if(typeof this.sayName != "function")&#123; Person.prototype.sayName = function()&#123; console.log(this.name); &#125;; &#125;;&#125;;var person = new Person('乔乔',16,'web前端工程师');person.sayName(); //乔乔 注意：使用动态原型模式时，不能使用对象字面量模式重写原型。如果在已经创建了实实例的情况下重写原型，那么就会切断现有实力与原型之间的联系，具体可参考我的另一篇文章原型和原型链。寄生构造函数模式这种模式的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象。这个模式可以在特殊情况下用来为对象创建构造函数。但存在一个问题，返回的对象与构造函数或者与构造函数的原型属性之间没有关系，也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同，不能以来instanceof操作符来确定对象类型。（不建议使用） 12345678910111213141516171819function SpecialArray()&#123; //创建数组 var values = new Array(); //添加值 values.push.apply(values,arguments); //添加方法 values.toPipedString = function()&#123; return this.join("|"); &#125;; //返回数组 return values;&#125;;var colors = new SpecialArray("red","blue","green");console.log(colors.toPipedString()); //red|blue|green 稳妥构造函数模式所谓稳妥对象，指的是没有公共属性，而且其方法也不引用this的对象。稳妥对象最适合在一些安全的环境中（这些环境中会禁止使用this和new），或者在防止数据被其他应用程序改动时使用。稳妥构造函数遵循与寄生构造函数类似的模式，但有亮点不同：一是创建对象的实例方法不引用this；二是不使用new操作符调用构造函数。与寄生构造函数模式类似，使用稳妥构造函数模式创建的对象与构造函数之间也没有什么关系，因此instanceof操作符对这种对象也没有意义。 123456789101112131415161718function Person(name,age,job)&#123; //创建要返回的对象 var obj = new Object(); //可以在这里定义私有变量和函数 //添加方法 obj.sayName = function()&#123; console.log(name); &#125;; //返回对象 return obj;&#125;;var person = new Person('乔乔',16,'web前端工程师');person.sayName(); //乔乔 注意：在以这种模式创建的对象中，除了使用sayName()方法之外，没有其他办法访问name的值。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>Object</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解对象]]></title>
    <url>%2F2019%2F08%2F12%2F%E7%90%86%E8%A7%A3%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[什么是对象？对象是无序属性的集合，其属性可以包含基本值、对象或者函数，在javascript中，对象是拥有属性和方法的数据。 每个对象都是基于一个引用类创建的。 创建对象的方式 创建自定义对象的最简单方式就是创建一个Object的实例，然后再为它添加属性和方法。 12345678var obj = new Object();obj.name = 'qyx';obj.age = 18;obj.job = 'web开发工程师'；obj.sayName = function()&#123; alert(this.name);&#125;; 使用new关键字来创建一个拥有独立内存区域和指向原型的指针的对象。当我们使用的new的时候，js解析器会分配一块内存空间，用以存放当前的对象的自有属性。之后解析器会给这一对象一个proto属性指向的原型对象内容。 对象直接量创建 12345678var obj = &#123; name:'qyx', age:18, job:'web开发工程师', sayName:function()&#123; alert(this.name); &#125;&#125; 这种方法就是直接通过花括号包裹的键值对的形式来定义当前对象的。每两个属性值之间的通过逗号来进行分割。键和值之间通过冒号来分割。 使用Object.create()方法 1234567var obj = Object.create(&#123; name:'qyx', age:18, job:'web开发工程师', sayName:function()&#123; alert(this.name); &#125;); 这一方法是ECMAScript5中定义的一个内容，它是一个静态方法,传入的参数是一个对象，并且这一作用的对象将会作为新的对象的原型存在。 属性类型ECMAscript中有两种属性：数据属性和访问器属性 1.Object.defineProperty()方法接受三个参数：属性所在的对象、属性的名字和一个描述符对象。 2.访问器属性不包含数据值，它们包含一对儿getter和setter 函数（非必须），在读取访问器属性时，会调用getter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter函数并传入新值，这个函数负责决定如何处理数据。 3.对象属性的类型可以是object，string，number，boolean，null和undefined。虽然字符串，数字，和布尔值虽然不是对象，但是性质和不可变对象类似的。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>Object</tag>
      </tags>
  </entry>
</search>
