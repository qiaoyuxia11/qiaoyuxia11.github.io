<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[原型和原型链]]></title>
    <url>%2F2019%2F08%2F16%2F%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[对于初学者来说，JavaScript的原型是一件让人头疼甚至吐血的事情，prototype和__proto__又让人傻傻分不清，虽然网上有很多相关资料，还有一张经典的图，线条很多，看的就头疼，更甚者吐血身亡，就算是对于“老人”，也不好整明白呀，或者好不容易搞清楚了，过几天又忘了（我就是这样，嘿嘿）。接下来请用许我尽可能形象生动的来阐述明白，哈哈哈哈哈。。。 理解原型对象prototype 和 __proto__ ？prototype是只有函数才会有的属性；而__proto__是所有对象都有的属性。几乎所有的函数都有一个prototype属性，prototype上挂载的所有属性和方法都可以被这个函数的实例继承。 不管什么时候，只要你创建了一个函数，它就会具有prototype属性，这个属性指向函数的原型对象。默认情况下所有的对象都会又一个constructor(构造函数属性)，这个属性指向prototype属性所在函数的指针。emm~ 是不是看晕了？没关系，让我们来点代码和配图，你可以直接吐了。 1234function Person()&#123;&#125;; //这个是一个构造函数Person.prototype //这个是函数的原型对象var person1 = new Person(); // 调用构造函数创建的实例var person2 = new Person(); // 调用构造函数创建的实例 代码分析：创建了一个自定义的构造函数之后，其原型对象默认会取得一个constructor属性，Person.prototype.constructor指向的是Person,当调用一个构造函数创建一个实例之后，该实例的内部就会有一个指针__proto__（内部属性[[Prototype]]）,指向构造函数的原型对象，这个连接存在与实例与构造函数的原型对象之间，而不是实例与构造函数之间。 123Person.prototype===person1.__proto__ //trueperson1.__proto__.constructor === person1.constructor===Person // truePerson.constructor===Function // true 扩展：如果[[Prototype]]指向调用isPrototype()方法的对象）（Person.prototype），那么这个方法就会返回true。 12console.log(Person.prototype.isPrototypeOf(person1)); // true console.log(Person.prototype.isPrototypeOf(person2)); // true ECMAScript5 增加了一个新方法 Object.getPrototypeOf()。 1console.log(Object.getPrototypeOf(person1) === Person.prototype); // true 怎么样？你还行吗？还行的话来张经典图片，嘿嘿。。 自有属性和原型属性每当代码读取某个对象的某个属性时，都会执行一次搜索，搜索顺序是先自有属性然后原型属性。即先从对象实例本身开始，如果在实例中找到了这个属性就返回对应的值，如果没有找到则再到原型对象上查找，查找到就该属性的值，若是没有的话就返回undefind.下面来举个例子说明： 12345678910function Person()&#123;&#125;Person.prototype.name = '乔乔';Person.prototype.age = 16;Person.prototype.job = 'web前端工程师';Person.prototype.sayName = function()&#123; alert(this.name);&#125;;var person1 = new Person();person1.sayName(); //'乔乔'; 分析：在我们调用person1.sayName()的时候，会执行两次搜索。解析器：“实例person1有sayName属性吗？”答：“没有”解析器：“person1的原型有sayName属性吗”答：“有”于是，就读到原型对象中的函数。 扩展：原型最初只包含constructor属性，而该属性也是共享的，因此可以通过对象实例访问。！注意 可以通过对象实例访问保存在原型中的值，但不能通过对象实例重写原型中的值。 实例和原型中的属性同名时，该属性会自动屏蔽原型中的属性，选择实例中的属性，不过使用detele操作符可以完全删除实例属性，从而从新访问原型中的属性。 使用hasOwnPrototy()方法可以检测一个属性是否存在于实例中，若实例中存在，则返回true。如果我们想要知道某个属性是否在原型上，就需要自己写一个函数： const hasPrototypeProperty=(obj,key)=&gt;(key in obj)&amp;&amp;(!obj.hasOwnProperty(key))代码： 123456789101112131415161718192021function Person()&#123;&#125;;Person.prototype.name = 'qiaoqiao';Person.prototype.age = 18;Person.prototype.job = '前端';Person.prototype.sayName = function()&#123; console.log(this.name)&#125;;var person1 = new Person();var person2 = new Person();person1.name = 'xiaomin';console.log(person1.name); //xiaomin 来自实例console.log(person2.name);//qiaoqiao 来自原型console.log(person1.hasOwnPrototy(name));//trueconsole.log(person2.hasOwnPrototy(name));//falsedetele person1.name;console.log(person1.name);//qiaoqiao 来自原型 扩展：Object.getOwnPropertyDescriptor()方法只能用于实例属性。更多请自行百度哟！！原型与in操作两种方法：单独使用：无论是存在于实例中还是原型中，只要能访问到就会返回true。for-in循环中使用:返回所有能够通过对象访问的、克枚举的属性，屏蔽了原型中的不可枚举的属性。 Object.keys()方法接受一个对象作为参数，返回一个包含所有可枚举实例属性的字符串数组。Object.getOwnPropertyNames()方法可以得到所有的实例属性，无论是否可枚举。 12345678function Person()&#123;&#125;;Person..prototype.name = 'qiaoqiao';var person1 = new Person();person1.hobby = 'comic';console.log("name" in person1) ; //trueconsole.log("hobby" in person1) ; //true 实例对象之间的关系12345678910function Person()&#123;&#125;;const person1=new Person();const person2=new Person();person1==person2; // false,这是因为在这里都指向不同的内存，&#123;&#125;===&#123;&#125; // falseJSON.stringify(person1)===JSON.stringify(person2); // trueperson1.constructor===person2.constructor; // true 这里的构造函数都指向Person，所以为trueperson1.__proto__===person2.__proto__ ;// 当然这个也为trueperson1.__proto__===Person.prototype ;// trueObject.getPrototypeOf(person1)===Object.getPrototypeOf(person2) ;// true 相关的原型语法前面的例子中，原型的属性都是通过Person.prototype一个一个添加上去的，原型对象的constructor指向构造函数，其实也可以使用对象的字面量来重写整个原型的对象，但是重写之后的constructor已经不再指向构造函数，而是指向Object。 123456789101112function Person()&#123;&#125;;Person.prototype = &#123; name:'qiaoqiao', age:16&#125;var obj = new Person();console.log(obj instanceof Object); // trueconsole.log(obj instanceof Person); // trueconsole.log(obj.constructor == Person); // falseconsole.log(obj.constructor == Object); // true 虽然用instanceof操作符测试Object和Person仍然返回true，但是constuctor属性则等于Object而不等于Person了。如果constructor的值很重要的话，可以通过一下方式设置： 1234567function Person()&#123;&#125;;Person.prototype = &#123; constructor:Person, name:'qiaoqiao', age:16&#125; 重写原型对象会切断现有原型与任何之前已经存在的对象实例之间的联系，它们的引用依然是最初的原型。 1234567891011121314function Person()&#123;&#125;;var obj = new Person();Person.prototype = &#123; name:'qiaoqiao', age:16, job:'前端', sayName:function()&#123; console.log(this.name); &#125;;&#125;;obj.sayName(); // error prototype是js面向对象的一个重要机制，说难很难，说简单也简单，原型链最终指向null。首先要明确：函数（Function）才有prototype属性，对象（除Object）拥有__proto__。原型链的顶层就是Object.prototype，而这个对象的是没有原型对象的，在chrome控制台中输入Object.__proto__，输出是ƒ () { }，一个空的函数。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>Object</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象的程序设计模式]]></title>
    <url>%2F2019%2F08%2F15%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[工厂模式工厂模式是软件工程领域一种广为认知的设计模式。工厂模式虽然解决了创建多个对象的问题，但却没有解决对象的识别问题（即怎样知道一个对象的类型）。 12345678910111213function createPerson(name,age,job)&#123; var obj = new Object(); obj.name = name; obj.age = age; obj.job = job; obj.sayName = function()&#123; alert(this.name); &#125;; return obj;&#125;;var person1 = createPerson('乔乔',16,'web前端工程师')；var person2 = createPerson('小敏',18,'web前端工程师')； 构造函数模式可以创建原生构造函数也可以创建自定义的构造函数。 1234567891011function Person(name,age,job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = function()&#123; alert(this.name); &#125;;&#125;var person1 = new Person('乔乔',16,'web前端工程师');var person2 = new Person('小敏',18,'web前端工程师'); 与工厂模式相比，部分代码相同，不同之处： 没有显示的创建对象； 直接将属性和方法赋给了this对象； 没有return语句。 按照惯例，构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头。 对象有一个constructor(构造函数)属性，最初是用来标识对象类型的，该属性指向构造函数。上述例子中的person1和person2的constructor指向Person。 123456console.log(person1.constructor == Person); //trueconsole.log(person2.constructor == Person); //trueconsole.log(person1 instanceof Object); //trueconsole.log(person1 instanceof Person); //trueconsole.log(person2 instanceof Object); //trueconsole.log(person2 instanceof Person); //true 使用new操作会经历以下4个步骤： 创建一个新对象； 将构造函数的作用域赋给新对象（因此this就指向这个新对象）； 执行构造函数中的代码（为这个新对象添加属性） 返回新对象。 将构造函数当作函数构造函数也是函数，通过new操作符调用的话，就是构造函数，不通过new操作符调用的话就是普通函数。以前面的例子为例： 当作构造函数使用 12var person = new Person('乔乔',16,'web前端工程师');person.sayName(); //'乔乔' 作为普通函数调用 12Person('乔乔',16,'web前端工程师');window.sayName(); //'乔乔'; 在另一个对象的作用域中调用 123var obj = new Object();Person.call(obj,'乔乔',16,'web前端工程师');obj..sayName(); //'乔乔'; 构造函数的问题缺点：每个方法都要在每个实例上重新创建一边，因为函数是对象，因此每定义一个函数，也就是实例化了一个对象。以这种方式创建函数，会导致不同的作用域链和标识符解析，但创建Function新实例的机制依然是相同的，因此不同函实例上的同名函数是不相等的。 1console.log(person1.sayName == person2.sayName); //false 可以通过把函数定义装一刀构造函数外部来解决这个问题。 12345678910111213function Person(name,age,job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = sayName;&#125;;function sayName()&#123; alert(this.name);&#125;;var person1 = new Person('乔乔',16,'web前端工程师');var person2 = new Person('小敏',18,'web前端工程师'); 这样通过定义一个全局的函数，解决了两个函数做同一件事的问题，但是又会有新的问题：如果对象需要定义很多方法，那么就要定义很多个全局函数。这个问题可以通过使用原型模式来解决。 原型模式我们创建的每一个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法（好处）。 1234567891011121314151617function Person()&#123;&#125;Person.prototype.name = '乔乔';Person.prototype.age = 16;Person.prototype.job = 'web前端工程师';Person.prototype.sayName = function()&#123; alert(this.name);&#125;;var person1 = new Person();person1.sayName(); //'乔乔';var person2 = new Person();person2.sayName(); //'乔乔';console.log(person1.sayName() == person2.sayName()); //true 由此可以看出，person1和person2访问的都是同一组属性和同一个sayName()函数。 组合使用构造函数模式和原型模式这是创建自定义类型的最常见方式，构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。每个实例都会有自己实例属性的一份副本，但同时又共享着对方法的引用，最大限度地节省了内存。 1234567891011121314151617181920212223function Person(name,age,job)&#123; this.name = name; this.age = age; this.job = job; this.friends = ["许大敏","游小敏"];&#125;;Person.prototype = &#123; constructor:Person, sayName:function()&#123; alert(this.name); &#125;&#125;var person1 = new Person('乔乔',16,'web前端工程师');var person2 = new Person('小敏',18,'web前端工程师');person1.friends.push("乔小小");console.log(person1.friends); //["许大敏","游小敏","乔小小"]console.log(person2.friends); //["许大敏","游小敏"]console.log(person1.friends == person2.friends); //false console.log(person1.sayName == person1.sayName); //true 动态原型模式把所有信息都封装在构造函数中，通过在构造函数初始化原型（在必要的情况下），换句话说，可以通过检查某个存放的方法是否有效，来决定是否初始化原型。 123456789101112131415function Person(name,age,job)&#123; this.name = name; this.age = age; this.job = job; //方法,也可以使用instanceof if(typeof this.sayName != "function")&#123; Person.prototype.sayName = function()&#123; console.log(this.name); &#125;; &#125;;&#125;;var person = new Person('乔乔',16,'web前端工程师');person.sayName(); //乔乔 注意：使用动态原型模式时，不能使用对象字面量模式重写原型。如果在已经创建了实实例的情况下重写原型，那么就会切断现有实力与原型之间的联系，具体可参考我的另一篇文章原型和原型链。寄生构造函数模式这种模式的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象。这个模式可以在特殊情况下用来为对象创建构造函数。但存在一个问题，返回的对象与构造函数或者与构造函数的原型属性之间没有关系，也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同，不能以来instanceof操作符来确定对象类型。（不建议使用） 12345678910111213141516171819function SpecialArray()&#123; //创建数组 var values = new Array(); //添加值 values.push.apply(values,arguments); //添加方法 values.toPipedString = function()&#123; return this.join("|"); &#125;; //返回数组 return values;&#125;;var colors = new SpecialArray("red","blue","green");console.log(colors.toPipedString()); //red|blue|green 稳妥构造函数模式所谓稳妥对象，指的是没有公共属性，而且其方法也不引用this的对象。稳妥对象最适合在一些安全的环境中（这些环境中会禁止使用this和new），或者在防止数据被其他应用程序改动时使用。稳妥构造函数遵循与寄生构造函数类似的模式，但有亮点不同：一是创建对象的实例方法不引用this；二是不使用new操作符调用构造函数。与寄生构造函数模式类似，使用稳妥构造函数模式创建的对象与构造函数之间也没有什么关系，因此instanceof操作符对这种对象也没有意义。 123456789101112131415161718function Person(name,age,job)&#123; //创建要返回的对象 var obj = new Object(); //可以在这里定义私有变量和函数 //添加方法 obj.sayName = function()&#123; console.log(name); &#125;; //返回对象 return obj;&#125;;var person = new Person('乔乔',16,'web前端工程师');person.sayName(); //乔乔 注意：在以这种模式创建的对象中，除了使用sayName()方法之外，没有其他办法访问name的值。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>Object</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解对象]]></title>
    <url>%2F2019%2F08%2F12%2F%E7%90%86%E8%A7%A3%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[什么是对象？对象是无序属性的集合，其属性可以包含基本值、对象或者函数，在javascript中，对象是拥有属性和方法的数据。 每个对象都是基于一个引用类创建的。 创建对象的方式 创建自定义对象的最简单方式就是创建一个Object的实例，然后再为它添加属性和方法。 12345678var obj = new Object();obj.name = 'qyx';obj.age = 18;obj.job = 'web开发工程师'；obj.sayName = function()&#123; alert(this.name);&#125;; 使用new关键字来创建一个拥有独立内存区域和指向原型的指针的对象。当我们使用的new的时候，js解析器会分配一块内存空间，用以存放当前的对象的自有属性。之后解析器会给这一对象一个proto属性指向的原型对象内容。 对象直接量创建 12345678var obj = &#123; name:'qyx', age:18, job:'web开发工程师', sayName:function()&#123; alert(this.name); &#125;&#125; 这种方法就是直接通过花括号包裹的键值对的形式来定义当前对象的。每两个属性值之间的通过逗号来进行分割。键和值之间通过冒号来分割。 使用Object.create()方法 1234567var obj = Object.create(&#123; name:'qyx', age:18, job:'web开发工程师', sayName:function()&#123; alert(this.name); &#125;); 这一方法是ECMAScript5中定义的一个内容，它是一个静态方法,传入的参数是一个对象，并且这一作用的对象将会作为新的对象的原型存在。 属性类型ECMAscript中有两种属性：数据属性和访问器属性 1.Object.defineProperty()方法接受三个参数：属性所在的对象、属性的名字和一个描述符对象。 2.访问器属性不包含数据值，它们包含一对儿getter和setter 函数（非必须），在读取访问器属性时，会调用getter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter函数并传入新值，这个函数负责决定如何处理数据。 3.对象属性的类型可以是object，string，number，boolean，null和undefined。虽然字符串，数字，和布尔值虽然不是对象，但是性质和不可变对象类似的。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>Object</tag>
      </tags>
  </entry>
</search>
