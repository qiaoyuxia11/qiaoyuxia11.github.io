<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[面向对象的程序设计模式]]></title>
    <url>%2F2019%2F08%2F15%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[工厂模式工厂模式是软件工程领域一种广为认知的设计模式。工厂模式虽然解决了创建多个对象的问题，但却没有解决对象的识别问题（即怎样知道一个对象的类型）。 12345678910111213function createPerson(name,age,job)&#123; var obj = new Object(); obj.name = name; obj.age = age; obj.job = job; obj.sayName = function()&#123; alert(this.name); &#125;; return obj;&#125;;var person1 = createPerson('乔乔',16,'web前端工程师')；var person2 = createPerson('小敏',18,'web前端工程师')； 构造函数模式可以创建原生构造函数也可以创建自定义的构造函数。 1234567891011function Person(name,age,job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = function()&#123; alert(this.name); &#125;;&#125;var person1 = new Person('乔乔',16,'web前端工程师');var person2 = new Person('小敏',18,'web前端工程师'); 与工厂模式相比，部分代码相同，不同之处： 没有显示的创建对象； 直接将属性和方法赋给了this对象； 没有return语句。 按照惯例，构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头。 对象有一个constructor(构造函数)属性，最初是用来标识对象类型的，该属性指向构造函数。上述例子中的person1和person2的constructor指向Person。 123456console.log(person1.constructor == Person); //trueconsole.log(person2.constructor == Person); //trueconsole.log(person1 instanceof Object); //trueconsole.log(person1 instanceof Person); //trueconsole.log(person2 instanceof Object); //trueconsole.log(person2 instanceof Person); //true 使用new操作会经历以下4个步骤： 创建一个新对象； 将构造函数的作用域赋给新对象（因此this就指向这个新对象）； 执行构造函数中的代码（为这个新对象添加属性） 返回新对象。 将构造函数当作函数构造函数也是函数，通过new操作符调用的话，就是构造函数，不通过new操作符调用的话就是普通函数。以前面的例子为例： 当作构造函数使用 12var person = new Person('乔乔',16,'web前端工程师');person.sayName(); //'乔乔' 作为普通函数调用 12Person('乔乔',16,'web前端工程师');window.sayName(); //'乔乔'; 在另一个对象的作用域中调用 123var obj = new Object();Person.call(obj,'乔乔',16,'web前端工程师');obj..sayName(); //'乔乔'; 构造函数的问题缺点：每个方法都要在每个实例上重新创建一边，因为函数是对象，因此每定义一个函数，也就是实例化了一个对象。以这种方式创建函数，会导致不同的作用域链和标识符解析，但创建Function新实例的机制依然是相同的，因此不同函实例上的同名函数是不相等的。 1console.log(person1.sayName == person2.sayName); //false 可以通过把函数定义装一刀构造函数外部来解决这个问题。 12345678910111213function Person(name,age,job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = sayName;&#125;;function sayName()&#123; alert(this.name);&#125;;var person1 = new Person('乔乔',16,'web前端工程师');var person2 = new Person('小敏',18,'web前端工程师'); 这样通过定义一个全局的函数，解决了两个函数做同一件事的问题，但是又会有新的问题：如果对象需要定义很多方法，那么就要定义很多个全局函数。这个问题可以通过使用原型模式来解决。 原型模式我们创建的每一个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法（好处）。 1234567891011121314151617function Person()&#123;&#125;Person.prototype.name = '乔乔';Person.prototype.age = 16;Person.prototype.job = 'web前端工程师';Person.prototype.sayName = function()&#123; alert(this.name);&#125;;var person1 = new Person();person1.sayName(); //'乔乔';var person2 = new Person();person2.sayName(); //'乔乔';console.log(person1.sayName() == person2.sayName()); //true 由此可以看出，person1和person2访问的都是同一组属性和同一个sayName()函数。 组合使用构造函数模式和原型模式这是创建自定义类型的最常见方式，构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。每个实例都会有自己实例属性的一份副本，但同时又共享着对方法的引用，最大限度地节省了内存。 1234567891011121314151617181920212223function Person(name,age,job)&#123; this.name = name; this.age = age; this.job = job; this.friends = ["许大敏","游小敏"];&#125;;Person.prototype = &#123; constructor:Person, sayName:function()&#123; alert(this.name); &#125;&#125;var person1 = new Person('乔乔',16,'web前端工程师');var person2 = new Person('小敏',18,'web前端工程师');person1.friends.push("乔小小");console.log(person1.friends); //["许大敏","游小敏","乔小小"]console.log(person2.friends); //["许大敏","游小敏"]console.log(person1.friends == person2.friends); //false console.log(person1.sayName == person1.sayName); //true 动态原型模式把所有信息都封装在构造函数中，通过在构造函数初始化原型（在必要的情况下），换句话说，可以通过检查某个存放的方法是否有效，来决定是否初始化原型。 123456789101112131415function Person(name,age,job)&#123; this.name = name; this.age = age; this.job = job; //方法,也可以使用instanceof if(typeof this.sayName != "function")&#123; Person.prototype.sayName = function()&#123; console.log(this.name); &#125;; &#125;;&#125;;var person = new Person('乔乔',16,'web前端工程师');person.sayName(); //乔乔 注意：使用动态原型模式时，不能使用对象字面量模式重写原型。如果在已经创建了实实例的情况下重写原型，那么就会切断现有实力与原型之间的联系，具体可参考我的另一篇文章原型和原型链。寄生构造函数模式这种模式的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象。这个模式可以在特殊情况下用来为对象创建构造函数。但存在一个问题，返回的对象与构造函数或者与构造函数的原型属性之间没有关系，也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同，不能以来instanceof操作符来确定对象类型。（不建议使用） 12345678910111213141516171819function SpecialArray()&#123; //创建数组 var values = new Array(); //添加值 values.push.apply(values,arguments); //添加方法 values.toPipedString = function()&#123; return this.join("|"); &#125;; //返回数组 return values;&#125;;var colors = new SpecialArray("red","blue","green");console.log(colors.toPipedString()); //red|blue|green 稳妥构造函数模式所谓稳妥对象，指的是没有公共属性，而且其方法也不引用this的对象。稳妥对象最适合在一些安全的环境中（这些环境中会禁止使用this和new），或者在防止数据被其他应用程序改动时使用。稳妥构造函数遵循与寄生构造函数类似的模式，但有亮点不同：一是创建对象的实例方法不引用this；二是不使用new操作符调用构造函数。与寄生构造函数模式类似，使用稳妥构造函数模式创建的对象与构造函数之间也没有什么关系，因此instanceof操作符对这种对象也没有意义。 123456789101112131415161718function Person(name,age,job)&#123; //创建要返回的对象 var obj = new Object(); //可以在这里定义私有变量和函数 //添加方法 obj.sayName = function()&#123; console.log(name); &#125;; //返回对象 return obj;&#125;;var person = new Person('乔乔',16,'web前端工程师');person.sayName(); //乔乔 注意：在以这种模式创建的对象中，除了使用sayName()方法之外，没有其他办法访问name的值。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>Object</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解对象]]></title>
    <url>%2F2019%2F08%2F12%2F%E7%90%86%E8%A7%A3%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[什么是对象？对象是无序属性的集合，其属性可以包含基本值、对象或者函数，在javascript中，对象是拥有属性和方法的数据。 每个对象都是基于一个引用类创建的。 创建对象的方式 创建自定义对象的最简单方式就是创建一个Object的实例，然后再为它添加属性和方法。 12345678var obj = new Object();obj.name = 'qyx';obj.age = 18;obj.job = 'web开发工程师'；obj.sayName = function()&#123; alert(this.name);&#125;; 使用new关键字来创建一个拥有独立内存区域和指向原型的指针的对象。当我们使用的new的时候，js解析器会分配一块内存空间，用以存放当前的对象的自有属性。之后解析器会给这一对象一个proto属性指向的原型对象内容。 对象直接量创建 12345678var obj = &#123; name:'qyx', age:18, job:'web开发工程师', sayName:function()&#123; alert(this.name); &#125;&#125; 这种方法就是直接通过花括号包裹的键值对的形式来定义当前对象的。每两个属性值之间的通过逗号来进行分割。键和值之间通过冒号来分割。 使用Object.create()方法 1234567var obj = Object.create(&#123; name:'qyx', age:18, job:'web开发工程师', sayName:function()&#123; alert(this.name); &#125;); 这一方法是ECMAScript5中定义的一个内容，它是一个静态方法,传入的参数是一个对象，并且这一作用的对象将会作为新的对象的原型存在。 属性类型ECMAscript中有两种属性：数据属性和访问器属性 1.Object.defineProperty()方法接受三个参数：属性所在的对象、属性的名字和一个描述符对象。 2.访问器属性不包含数据值，它们包含一对儿getter和setter 函数（非必须），在读取访问器属性时，会调用getter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter函数并传入新值，这个函数负责决定如何处理数据。 3.对象属性的类型可以是object，string，number，boolean，null和undefined。虽然字符串，数字，和布尔值虽然不是对象，但是性质和不可变对象类似的。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>Object</tag>
      </tags>
  </entry>
</search>
